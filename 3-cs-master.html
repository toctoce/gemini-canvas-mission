<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IT 취준생 CS 면접 대비 퀴즈</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        /* 커스텀 애니메이션 및 스타일 */
        body {
            background-color: #0f172a; /* Tailwind slate-900 */
            color: #f8fafc; /* Tailwind slate-50 */
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }
        .fade-in {
            animation: fadeIn 0.3s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .shake {
            animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
        }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }
        /* 스크롤바 커스텀 */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

    <!-- 메인 앱 컨테이너 -->
    <div id="app" class="w-full max-w-2xl bg-slate-800 rounded-2xl shadow-2xl overflow-hidden border border-slate-700 fade-in">
        <!-- 내용이 JS를 통해 동적으로 렌더링됩니다 -->
    </div>

    <script>
        // --- 1. 데이터베이스 (모의 DB) ---
        // 실제 운영 시 이 부분을 API 호출이나 Firebase Firestore 연동으로 교체할 수 있습니다.
        const quizDB = {
            os: [
                { q: "실행 중인 프로그램을 의미하며, 운영체제로부터 자원을 할당받는 작업의 단위는 무엇인가요?", a: ["프로세스", "process"], exp: "프로세스(Process)는 디스크에 있던 프로그램이 메모리에 적재되어 실행 중인 상태를 말합니다." },
                { q: "프로세스 내에서 실행되는 여러 흐름의 단위로, 프로세스의 자원을 공유하는 것은 무엇인가요?", a: ["스레드", "thread"], exp: "스레드(Thread)는 프로세스 내의 제어 흐름 단위이며, 프로세스의 코드, 데이터, 힙 영역을 공유합니다." },
                { q: "두 개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해 다음 처리를 하지 못하는 무한 대기 상태를 무엇이라 하나요?", a: ["데드락", "교착상태", "deadlock"], exp: "데드락(Deadlock)의 발생 조건은 상호배제, 점유대기, 비선점, 순환대기입니다." },
                { q: "가상 메모리를 일정한 크기의 블록으로 나누어 관리하는 기법은 무엇인가요?", a: ["페이징", "paging", "페이징기법"], exp: "페이징(Paging)은 논리적 주소 공간을 동일한 크기의 페이지로 나누고, 물리적 메모리를 동일한 크기의 프레임으로 나누어 매핑하는 기법입니다." },
                { q: "CPU가 현재 실행 중인 프로세스의 상태를 저장하고, 다음 실행할 프로세스의 상태를 복원하는 작업은 무엇인가요?", a: ["문맥교환", "컨텍스트스위칭", "context switching"], exp: "문맥 교환 시 오버헤드가 발생하며, 이는 프로세스 제어 블록(PCB)에 상태를 저장하고 읽어오는 과정에서 일어납니다." },
                { q: "운영체제가 프로세스를 제어하기 위해 프로세스의 상태 정보를 저장해 놓는 자료구조는 무엇인가요?", a: ["pcb", "프로세스제어블록"], exp: "PCB에는 프로세스 상태, 포인터, 프로그램 카운터, 레지스터 정보 등이 담겨 있습니다." },
                { q: "공유 자원에 대한 접근을 제어하기 위해 사용하는 정수형 변수로, P연산과 V연산으로 접근을 동기화하는 기법은?", a: ["세마포어", "semaphore"], exp: "세마포어는 여러 개의 스레드나 프로세스가 자원에 접근하는 것을 제어할 수 있습니다." },
                { q: "임계 구역을 가진 스레드들의 실행 시간이 서로 겹치지 않고 단독으로 실행되게 하는 동기화 기법은?", a: ["뮤텍스", "mutex", "상호배제"], exp: "뮤텍스는 자원 점유 상태를 락(Lock)과 언락(Unlock)으로 관리하여 오직 1개의 스레드만 접근을 허용합니다." },
                { q: "페이지 부재가 너무 잦게 발생하여 CPU가 실제 연산보다 페이지 교체에 더 많은 시간을 쓰는 현상은?", a: ["스래싱", "thrashing"], exp: "다중 프로그래밍 정도가 너무 높아지면 스래싱이 발생하여 CPU 이용률이 급격히 떨어집니다." },
                { q: "CPU가 프로그램을 실행하고 있을 때, 하드웨어 장치나 예외상황이 발생하여 처리가 필요함을 알리는 신호는?", a: ["인터럽트", "interrupt"], exp: "인터럽트가 발생하면 CPU는 하던 일을 멈추고 인터럽트 처리 루틴을 실행합니다." },
                { q: "운영체제의 핵심 부분으로, 하드웨어 자원을 관리하고 시스템 호출을 처리하는 소프트웨어는?", a: ["커널", "kernel"], exp: "커널은 운영체제의 심장부 역할을 합니다." },
                { q: "응용 프로그램이 운영체제의 커널 기능을 사용하기 위해 호출하는 프로그래밍 인터페이스는?", a: ["시스템콜", "system call", "시스템호출"], exp: "파일 입출력, 프로세스 제어 등을 위해 사용자 모드에서 커널 모드로 진입할 때 사용됩니다." },
                { q: "하나의 CPU로 여러 프로그램을 번갈아 실행하여 동시에 실행되는 것처럼 보이게 하는 기술은?", a: ["다중프로그래밍", "멀티프로그래밍", "multiprogramming"], exp: "CPU 이용률을 극대화하기 위해 고안되었습니다." },
                { q: "시분할 시스템을 위해 고안되었으며, 각 프로세스에 동일한 할당 시간을 주고 번갈아 실행하는 선점형 스케줄링은?", a: ["라운드로빈", "round robin", "rr"], exp: "할당 시간(Time Quantum)이 너무 크면 FCFS와 같아지고, 너무 작으면 문맥 교환 오버헤드가 커집니다." },
                { q: "우선순위가 낮은 프로세스가 자원을 계속 할당받지 못해 무한히 대기하는 현상은?", a: ["기아상태", "기아", "starvation"], exp: "SJF나 우선순위 스케줄링 등에서 발생할 수 있습니다." },
                { q: "기아 상태를 해결하기 위해 대기 시간이 길어질수록 프로세스의 우선순위를 점진적으로 높여주는 기법은?", a: ["에이징", "aging"], exp: "에이징 기법을 통해 오래 대기한 프로세스도 결국 실행될 수 있습니다." },
                { q: "다중 프로세스 환경에서 둘 이상의 스레드가 동시에 접근해서는 안 되는 공유 자원에 접근하는 코드 영역은?", a: ["임계구역", "critical section"], exp: "동기화 문제를 방지하기 위해 임계구역에는 한 번에 하나의 스레드만 진입해야 합니다." },
                { q: "임계구역 문제를 해결하기 위한 첫 번째 조건으로, 한 프로세스가 임계구역에 있으면 다른 프로세스는 들어갈 수 없다는 원칙은?", a: ["상호배제", "mutual exclusion"], exp: "상호배제, 진행, 한정대기 세 가지 조건을 모두 만족해야 완벽한 해결책입니다." },
                { q: "데드락 회피 알고리즘 중 하나로, 시스템이 안전 상태인지 검사하여 자원을 할당하는 다익스트라의 알고리즘은?", a: ["은행원알고리즘", "banker's algorithm"], exp: "자원 할당 전 모든 프로세스가 완료될 수 있는 안전 순서열이 존재하는지 확인합니다." },
                { q: "메모리 할당 시 프로세스 크기보다 메모리 공간이 작아 할당하지 못하고 남는 빈 공간을 무엇이라 하나요?", a: ["외부단편화", "external fragmentation"], exp: "메모리 공간이 조각조각 나뉘어 총 용량은 충분하지만 할당하지 못하는 상태입니다." },
                { q: "할당된 메모리 공간이 프로세스 크기보다 커서 사용되지 않고 낭비되는 공간은?", a: ["내부단편화", "internal fragmentation"], exp: "페이징 기법 등 고정 크기 할당 방식에서 주로 발생합니다." },
                { q: "가상 메모리를 논리적 의미가 있는 다양한 크기의 블록으로 나누어 관리하는 기법은?", a: ["세그먼테이션", "segmentation"], exp: "코드, 데이터, 스택 등의 논리적 단위로 나눕니다." },
                { q: "주기억장치의 용량보다 큰 프로그램을 실행하기 위해 보조기억장치의 일부를 주기억장치처럼 사용하는 기술은?", a: ["가상메모리", "virtual memory"], exp: "물리적 메모리 크기의 한계를 극복할 수 있습니다." },
                { q: "프로그램 실행 시 처음부터 모든 페이지를 적재하지 않고, 필요한 페이지만 메모리에 적재하는 기법은?", a: ["요구페이징", "demand paging"], exp: "메모리 사용량을 줄이고 응답 시간을 개선합니다." },
                { q: "CPU가 접근하려는 페이지가 주기억장치에 없을 때 발생하는 현상은?", a: ["페이지폴트", "page fault", "페이지부재"], exp: "페이지 폴트가 발생하면 디스크에서 해당 페이지를 메모리로 가져와야 합니다." },
                { q: "페이지 교체 알고리즘 중 가장 먼저 메모리에 들어온 페이지를 먼저 내보내는 방식은?", a: ["fifo", "first in first out"], exp: "가장 단순하지만, 페이지 프레임을 늘려도 페이지 폴트가 증가하는 Belady의 모순이 발생할 수 있습니다." },
                { q: "페이지 교체 알고리즘 중 가장 오랫동안 사용되지 않은 페이지를 교체하는 방식은?", a: ["lru", "least recently used"], exp: "과거의 사용 기록을 바탕으로 미래를 예측하는 실용적인 알고리즘입니다." },
                { q: "CPU 스케줄러에 의해 선택된 프로세스에게 실제로 CPU 제어권을 넘겨주는 운영체제 모듈은?", a: ["디스패처", "dispatcher"], exp: "문맥 교환을 수행하고 사용자 프로그램의 적절한 위치로 점프시킵니다." },
                { q: "프로세스 간 통신을 위해 운영체제가 제공하는 메커니즘을 통틀어 이르는 영문 약자는?", a: ["ipc", "inter process communication"], exp: "파이프, 메시지 큐, 공유 메모리, 소켓 등이 있습니다." },
                { q: "메모리 부족 시 메모리에서 프로세스 전체를 보조기억장치로 내보내거나 들여오는 과정은?", a: ["스와핑", "swapping"], exp: "메모리에서 디스크로 가는 것을 Swap-out, 디스크에서 메모리로 오는 것을 Swap-in이라 합니다." },
                { q: "과거에 가장 적은 횟수로 참조된 페이지를 교체하는 페이지 교체 알고리즘은?", a: ["lfu", "least frequently used"], exp: "사용 빈도를 기준으로 페이지를 교체합니다." },
                { q: "LRU를 근사화한 알고리즘으로, 참조 비트(Reference Bit)를 두고 원형 큐를 순회하며 페이지를 교체하는 방식은?", a: ["클럭알고리즘", "clock algorithm", "nur", "not used recently"], exp: "하드웨어의 지원(참조 비트)을 받아 오버헤드를 줄인 방식입니다." },
                { q: "FIFO 페이지 교체 알고리즘에서 페이지 프레임 수를 늘려도 오히려 페이지 폴트가 증가하는 비정상적인 현상은?", a: ["벨라디의모순", "belady's anomaly"], exp: "LRU 등 스택 기반 알고리즘에서는 발생하지 않습니다." },
                { q: "두 개 이상의 프로세스나 스레드가 공유 자원에 동시에 접근하려고 경쟁하는 상태는?", a: ["경쟁상태", "레이스컨디션", "race condition"], exp: "이로 인해 데이터의 일관성이 깨질 수 있어 동기화가 필요합니다." },
                { q: "세마포어의 단점(사용자 실수)을 극복하기 위해, 프로그래밍 언어 수준에서 상호배제를 자동으로 보장해주는 고수준 동기화 구조는?", a: ["모니터", "monitor"], exp: "Java의 synchronized 키워드가 모니터를 기반으로 동작합니다." },
                { q: "일반 애플리케이션이 실행되며 제한된 권한만을 가지는 CPU 실행 모드는?", a: ["사용자모드", "user mode", "유저모드"], exp: "중요한 시스템 자원(I/O, 메모리 등)에 직접 접근할 수 없습니다." },
                { q: "운영체제가 실행되며 시스템의 모든 메모리와 하드웨어 명령어에 접근할 수 있는 특권 모드는?", a: ["커널모드", "kernel mode"], exp: "사용자 프로그램이 시스템 콜을 호출하면 이 모드로 전환됩니다." },
                { q: "다중 프로그래밍 환경에서 여러 작업의 입출력을 디스크 등 보조기억장치에 모아두었다가 처리하는 기법은?", a: ["스풀링", "spooling"], exp: "프린터에서 인쇄 대기열을 처리할 때 주로 사용됩니다." },
                { q: "가상 메모리 주소 변환을 빠르게 하기 위해, 최근에 사용된 페이지 테이블 항목을 캐싱하는 하드웨어 장치의 약자는?", a: ["tlb", "translation lookaside buffer"], exp: "TLB에 없는(TLB Miss) 경우에만 실제 메모리의 페이지 테이블을 참조합니다." },
                { q: "프로세스가 일정 시간 동안 집중적으로 참조하는 페이지들의 집합을 메모리에 한꺼번에 적재하여 스래싱을 방지하는 모델은?", a: ["워킹셋", "working set", "워킹셋모델"], exp: "시간적 지역성을 활용한 메모리 관리 기법입니다." },
                { q: "페이지 폴트 발생 비율(Page Fault Frequency)을 측정하여 그 비율에 따라 프로세스에 프레임을 동적으로 할당하는 기법은?", a: ["pff", "page fault frequency"], exp: "비율이 상한을 넘으면 프레임을 늘려주고 하한을 넘으면 회수합니다." },
                { q: "멀티스레드 환경에서 여러 스레드가 동시에 함수나 변수에 접근해도 프로그램의 실행에 문제가 없는 상태를 뜻하는 용어는?", a: ["스레드세이프", "thread-safe", "thread safe"], exp: "전역 변수 사용을 피하거나 락(Lock)을 사용하여 구현합니다." },
                { q: "하나의 물리적 서버에서 여러 개의 가상 머신(VM)을 실행하고 관리할 수 있게 해주는 소프트웨어 계층은?", a: ["하이퍼바이저", "hypervisor"], exp: "Type 1(네이티브)과 Type 2(호스트형)로 나뉩니다." },
                { q: "VM과 달리 하이퍼바이저와 게스트 OS 없이 호스트 OS의 커널을 공유하며 프로세스를 격리하는 경량화된 가상화 기술은?", a: ["컨테이너", "container", "도커", "docker"], exp: "오버헤드가 매우 적고 배포가 빠릅니다." },
                { q: "정해진 시간 내에 반드시 계산을 끝내고 결과를 내놓아야 하는 시스템을 위한 운영체제의 약자는?", a: ["rtos", "real time operating system", "실시간운영체제"], exp: "우주선, 자동차 제어, 의료 기기 등에 필수적입니다." },
                { q: "사용자가 아이콘이나 메뉴 등의 그래픽 요소를 마우스로 클릭하여 컴퓨터와 상호작용하는 인터페이스는?", a: ["gui", "graphic user interface", "그래픽유저인터페이스"], exp: "Windows, macOS의 기본 인터페이스입니다." },
                { q: "사용자가 텍스트로 명령어를 직접 입력하여 컴퓨터와 상호작용하는 인터페이스는?", a: ["cli", "command line interface"], exp: "리눅스의 터미널이나 윈도우의 명령 프롬프트가 해당합니다." },
                { q: "CPU, 메모리, 입출력 장치들이 데이터를 주고받기 위해 공유하는 핵심 통신 경로를 통틀어 무엇이라 하나요?", a: ["시스템버스", "system bus"], exp: "데이터 버스, 주소 버스, 제어 버스로 구성됩니다." },
                { q: "두 개 이상의 프로세서(CPU)가 협력하여 하나의 컴퓨터 시스템 내에서 작업을 병렬로 처리하는 기술은?", a: ["다중처리", "멀티프로세싱", "multiprocessing"], exp: "시스템의 신뢰성과 처리량을 높입니다." },
                { q: "하나의 응용 프로그램 내에서 여러 개의 스레드를 생성하여 작업을 병렬로 처리하는 프로그래밍 기법은?", a: ["멀티스레딩", "다중스레딩", "multithreading"], exp: "스레드 간 자원을 공유하므로 멀티프로세싱보다 문맥 교환 비용이 적습니다." }
            ],
            network: [
                { q: "인터넷 계층의 프로토콜로, 신뢰성 있는 연결지향형 데이터 전송을 보장하는 프로토콜은 무엇인가요?", a: ["tcp", "transmission control protocol"], exp: "TCP는 3-way handshaking을 통해 연결을 설정하고 데이터의 신뢰성을 보장합니다." },
                { q: "도메인 이름을 IP 주소로 변환해주는 시스템은 무엇인가요?", a: ["dns", "domain name system"], exp: "DNS는 사람이 읽을 수 있는 도메인 이름을 머신이 읽을 수 있는 IP 주소로 변환합니다." },
                { q: "웹 브라우저와 웹 서버 간에 데이터를 주고받기 위해 사용하는 애플리케이션 계층 통신 규약은?", a: ["http", "hypertext transfer protocol"], exp: "비연결성(Connectionless)과 무상태(Stateless) 특징을 가집니다." },
                { q: "서로 다른 네트워크를 연결하고, 패킷의 최적 경로를 찾아 전달하는 네트워크 장비는?", a: ["라우터", "router"], exp: "라우터는 네트워크 계층(OSI 3계층)에서 동작하며 라우팅 테이블을 기반으로 경로를 결정합니다." },
                { q: "네트워크 통신이 일어나는 과정을 7단계로 나눈 국제 표준화 기구(ISO)의 네트워크 모델은?", a: ["osi7계층", "osi 7 layer", "osi모델"], exp: "물리, 데이터링크, 네트워크, 전송, 세션, 표현, 응용 계층으로 나뉩니다." },
                { q: "비연결형 프로토콜로, 데이터의 전송 순서나 신뢰성보다 실시간 전송 속도가 더 중요할 때 사용하는 것은?", a: ["udp", "user datagram protocol"], exp: "UDP는 패킷의 도착 순서를 보장하지 않고 수신 확인을 하지 않아 속도가 빠릅니다." },
                { q: "네트워크 상에서 IP 주소를 물리적 네트워크 주소인 MAC 주소로 변환하기 위해 사용되는 프로토콜은?", a: ["arp", "address resolution protocol"], exp: "목적지 IP 주소를 기반으로 브로드캐스트하여 MAC 주소를 알아냅니다." },
                { q: "네트워크 인터페이스 카드(NIC)에 할당된 48비트의 고유한 하드웨어 물리적 주소는?", a: ["mac주소", "mac", "mac address"], exp: "IP 주소가 논리적 주소라면, MAC 주소는 기기 고유의 물리적 주소입니다." },
                { q: "HTTP URI를 통해 자원을 명시하고 HTTP Method를 통해 자원의 CRUD를 적용하는 아키텍처 스타일은?", a: ["rest", "rest api", "restful"], exp: "REST는 자원 기반의 구조로 웹 서비스 설계의 표준으로 자리잡았습니다." },
                { q: "서버에 가해지는 트래픽 부하를 여러 대의 서버로 고르게 분산시켜주는 기술이나 장비는?", a: ["로드밸런서", "로드밸런싱", "load balancer"], exp: "L4 로드밸런서(IP/Port 기반)와 L7 로드밸런서(응용 계층 데이터 기반)가 대표적입니다." },
                { q: "OSI 7계층에서 상위 계층의 데이터에 현재 계층의 헤더(제어 정보)를 덧붙여 하위 계층으로 보내는 과정은?", a: ["캡슐화", "encapsulation"], exp: "데이터를 전송할 때는 캡슐화, 수신할 때는 역캡슐화가 일어납니다." },
                { q: "OSI 7계층 중 물리적인 매체를 통해 인접한 노드 간의 신뢰성 있는 정보 전송을 담당하는 2계층은?", a: ["데이터링크계층", "data link layer"], exp: "이 계층의 전송 단위는 프레임(Frame)이며, 스위치가 이 계층에서 동작합니다." },
                { q: "OSI 7계층 중 여러 노드를 거칠 때마다 경로를 찾아주는 라우팅 기능을 수행하는 3계층은?", a: ["네트워크계층", "network layer"], exp: "IP 프로토콜이 대표적이며 전송 단위는 패킷(Packet)입니다." },
                { q: "인터넷 망 내에서 데이터를 패킷 단위로 나누어 목적지까지 전달하기 위한 네트워크 계층의 핵심 프로토콜은?", a: ["ip", "internet protocol"], exp: "비신뢰성, 비연결성의 특징을 가집니다." },
                { q: "IP 주소에서 네트워크 부분과 호스트 부분을 구분하기 위해 사용하는 비트열은?", a: ["서브넷마스크", "subnet mask"], exp: "IP 주소와 AND 연산을 통해 네트워크 주소를 알아낼 수 있습니다." },
                { q: "사설 IP 주소를 공인 IP 주소로 변환하여 외부 네트워크와 통신할 수 있게 해주는 기술은?", a: ["nat", "network address translation"], exp: "IP 주소 부족 문제를 해결하고 보안을 강화할 수 있습니다." },
                { q: "네트워크에 접속하는 컴퓨터에게 동적으로 IP 주소, 서브넷 마스크, 게이트웨이 등을 자동으로 할당해주는 프로토콜은?", a: ["dhcp", "dynamic host configuration protocol"], exp: "DHCP 덕분에 수동으로 IP를 설정하지 않아도 인터넷 사용이 가능합니다." },
                { q: "TCP 통신에서 연결을 설정하기 위해 클라이언트와 서버가 3번의 패킷(SYN, ACK)을 주고받는 과정은?", a: ["3wayhandshake", "3-way handshake"], exp: "데이터를 전송하기 전 논리적인 연결을 맺는 필수 과정입니다." },
                { q: "송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위해, 수신측이 처리할 수 있는 만큼만 송신측이 데이터를 보내도록 조절하는 기법은?", a: ["흐름제어", "flow control"], exp: "TCP의 슬라이딩 윈도우(Sliding Window)가 대표적인 흐름 제어 기법입니다." },
                { q: "네트워크 내의 패킷 수가 과도하게 증가하는 것을 방지하기 위해, 송신측의 데이터 전송량을 조절하는 기법은?", a: ["혼잡제어", "congestion control"], exp: "느린 시작(Slow Start), 혼잡 회피(Congestion Avoidance) 등의 알고리즘을 사용합니다." },
                { q: "하나의 IP 주소 내에서 실행 중인 여러 프로세스를 구분하기 위해 사용하는 16비트 논리적 식별자는?", a: ["포트", "port", "포트번호"], exp: "예를 들어 HTTP는 80번, HTTPS는 443번 포트를 기본으로 사용합니다." },
                { q: "애플리케이션 계층과 전송 계층 사이에 위치하며, 네트워크 통신의 끝점(End-point) 역할을 하는 인터페이스는?", a: ["소켓", "socket"], exp: "소켓은 IP 주소와 포트 번호의 조합으로 이루어집니다." },
                { q: "MAC 주소를 기반으로 프레임을 목적지 포트로만 전달하여 충돌을 방지하는 데이터 링크 계층 장비는?", a: ["스위치", "switch", "l2스위치"], exp: "단순히 모든 포트로 신호를 뿌리는 허브(Hub)보다 효율적입니다." },
                { q: "클라이언트가 자신을 거쳐 다른 네트워크에 접속할 수 있도록 대리 역할을 해주는 서버는?", a: ["프록시", "proxy", "프록시서버"], exp: "캐싱, 보안, 익명성 보장 등의 목적으로 사용됩니다." },
                { q: "HTTP 통신에 SSL/TLS 프로토콜을 더해 데이터를 암호화하여 전송하는 보안 통신 규약은?", a: ["https"], exp: "데이터 도청이나 변조를 막기 위해 공개키 및 대칭키 암호화 방식을 혼용합니다." },
                { q: "클라이언트의 상태 정보를 클라이언트(브라우저) 측에 저장하는 작은 텍스트 데이터는?", a: ["쿠키", "cookie"], exp: "HTTP의 무상태성을 보완하며 만료 시간이 지정되어 있습니다." },
                { q: "클라이언트의 상태 정보를 웹 서버 측에 저장하고, 클라이언트에게는 식별자(ID)만 부여하는 방식은?", a: ["세션", "session"], exp: "보안이 중요한 로그인 정보 등을 유지할 때 사용되며 쿠키를 기반으로 동작합니다." },
                { q: "인증에 필요한 정보들을 암호화된 JSON 포맷의 토큰으로 변환하여 클라이언트와 서버가 주고받는 방식은?", a: ["jwt", "json web token"], exp: "Header, Payload, Signature 세 부분으로 구성되며 세션 저장소 없이도 인증이 가능합니다." },
                { q: "현재 웹 페이지가 제공된 도메인이 아닌, 다른 도메인의 자원에 접근할 수 있도록 권한을 부여하는 체제는?", a: ["cors", "cross origin resource sharing", "교차출처리소스공유"], exp: "보안상의 이유로 브라우저는 기본적으로 SOP(동일 출처 정책)를 따르며, 이를 우회하기 위해 CORS 설정이 필요합니다." },
                { q: "네트워크를 통해 전송되는 데이터의 형식화된 블록으로, 헤더와 페이로드로 구성된 전송 단위는?", a: ["패킷", "packet"], exp: "데이터를 작게 나누어 전송함으로써 회선 독점을 막고 오류 복구를 쉽게 합니다." },
                { q: "TCP 통신을 종료할 때 클라이언트와 서버가 연결을 안전하게 해제하기 위해 주고받는 4번의 패킷 통신 과정은?", a: ["4wayhandshake", "4-way handshake"], exp: "종료 시점에는 FIN과 ACK 플래그를 사용합니다." },
                { q: "패킷이 송신측에서 출발하여 수신측에 도달한 후, 다시 송신측으로 응답이 돌아오기까지 걸리는 왕복 시간은?", a: ["rtt", "round trip time"], exp: "네트워크 지연 시간을 측정하는 중요한 지표입니다." },
                { q: "서로 다른 자율 시스템(AS) 간에 라우팅 정보를 교환하는 외부 라우팅 프로토콜의 약자는?", a: ["bgp", "border gateway protocol"], exp: "인터넷의 핵심 라우팅 프로토콜로 사용됩니다." },
                { q: "동일한 자율 시스템(AS) 내부에서 라우팅 정보를 교환하는 링크 상태 라우팅 프로토콜의 약자는?", a: ["ospf", "open shortest path first"], exp: "다익스트라 알고리즘을 사용하여 최단 경로를 계산합니다." },
                { q: "물리적인 배치와 상관없이 논리적으로 네트워크를 분할하여 브로드캐스트 도메인을 나누는 기술은?", a: ["vlan", "virtual lan", "가상랜"], exp: "보안 강화와 트래픽 관리에 유용합니다." },
                { q: "공중망을 마치 사설망처럼 사용하여 통신 내용을 암호화하고 보안을 유지하는 기술의 약자는?", a: ["vpn", "virtual private network", "가상사설망"], exp: "원격 근무나 사내망 접속에 널리 쓰입니다." },
                { q: "현재 주로 사용되는 IP 주소 체계로, 32비트로 구성되어 약 43억 개의 주소를 표현할 수 있는 것은?", a: ["ipv4"], exp: "주소 고갈 문제를 해결하기 위해 NAT가 널리 쓰이게 되었습니다." },
                { q: "IPv4의 주소 고갈 문제를 해결하기 위해 도입된 128비트 길이의 차세대 IP 주소 체계는?", a: ["ipv6"], exp: "거의 무한에 가까운 주소 할당이 가능하며 보안과 헤더 구조가 개선되었습니다." },
                { q: "하나의 송신자가 그룹 내의 가장 가까운 하나의 수신자에게만 데이터를 전송하는 라우팅 기법은?", a: ["애니캐스트", "anycast"], exp: "IPv6에서 도입되었으며 주로 DNS나 CDN에서 로드 밸런싱을 위해 사용됩니다." },
                { q: "하나의 송신자가 네트워크에 연결된 특정 그룹의 다수 수신자에게 동시에 데이터를 전송하는 방식은?", a: ["멀티캐스트", "multicast"], exp: "화상 회의나 인터넷 방송(IPTV) 등에 효율적입니다." },
                { q: "하나의 송신자가 같은 네트워크 상의 '모든' 기기에게 무조건적으로 데이터를 전송하는 방식은?", a: ["브로드캐스트", "broadcast"], exp: "ARP 요청이나 DHCP 탐색 등에 사용됩니다." },
                { q: "이더넷 환경에서 통신을 시작하기 전 회선 상태를 확인하고, 충돌이 발생하면 랜덤한 시간 후 재전송하는 매체 접근 제어 방식은?", a: ["csma/cd"], exp: "유선 랜(LAN)의 표준 기술로 사용되었습니다." },
                { q: "무선 랜(Wi-Fi) 환경에서 충돌을 회피하기 위해 통신 전 미리 신호를 보내(RTS/CTS) 채널을 예약하는 방식은?", a: ["csma/ca"], exp: "무선 환경에서는 충돌 감지(CD)가 어렵기 때문에 회피(CA)를 사용합니다." },
                { q: "인터넷을 통해 컴퓨터 간에 파일을 송수신하기 위해 사용되는 전통적인 애플리케이션 계층 프로토콜은?", a: ["ftp", "file transfer protocol"], exp: "기본적으로 20번(데이터), 21번(제어) 포트를 사용합니다." },
                { q: "원격으로 다른 컴퓨터에 로그인하거나 제어할 때 데이터를 암호화하여 보안을 강화한 프로토콜은?", a: ["ssh", "secure shell"], exp: "과거의 Telnet을 대체하여 사용되며 22번 포트를 씁니다." },
                { q: "클라이언트가 메일 서버로 이메일을 '전송'하거나 메일 서버 간에 메일을 주고받을 때 사용하는 프로토콜은?", a: ["smtp", "simple mail transfer protocol"], exp: "보통 25번 포트를 사용합니다." },
                { q: "사용자가 메일 서버에서 이메일을 '읽어올' 때 사용하며, 메일의 헤더만 먼저 다운로드하여 동기화하는 프로토콜은?", a: ["imap", "internet message access protocol"], exp: "POP3와 달리 여러 기기에서 동일한 메일함을 관리하기 좋습니다." },
                { q: "웹 통신의 보안을 위해 데이터 암호화, 무결성, 서버 인증을 제공하는 보안 프로토콜 규약(최신 버전 포함)은?", a: ["tls", "ssl", "ssl/tls"], exp: "HTTPS의 기반이 되며 핸드셰이크 과정에서 암호화 키를 교환합니다." },
                { q: "TCP 3-way handshake의 취약점을 노려 서버에 SYN 패킷만 무수히 보내 연결 자원을 고갈시키는 공격은?", a: ["syn플러딩", "syn flooding", "syn flood"], exp: "대표적인 서비스 거부(DoS) 공격 중 하나입니다." },
                { q: "네트워크 계층(ICMP)을 이용하여 특정 IP를 가진 호스트가 살아서 통신 가능한 상태인지 점검하는 명령어는?", a: ["핑", "ping"], exp: "Echo Request와 Echo Reply 메시지를 사용합니다." }
            ],
            datastructure: [
                { q: "LIFO(Last In First Out) 구조로, 함수 호출이나 괄호 검사에 주로 사용되는 자료구조는?", a: ["스택", "stack"], exp: "스택은 가장 나중에 삽입된 데이터가 가장 먼저 삭제됩니다." },
                { q: "FIFO(First In First Out) 구조로, 대기열이나 너비 우선 탐색(BFS)에 주로 사용되는 자료구조는?", a: ["큐", "queue"], exp: "큐는 가장 먼저 삽입된 데이터가 가장 먼저 삭제됩니다." },
                { q: "키를 해시 함수를 거쳐 인덱스로 변환하여 데이터를 저장하는 속도가 매우 빠른 자료구조는?", a: ["해시테이블", "해시", "hash table"], exp: "평균 O(1)의 시간 복잡도로 데이터를 탐색/삽입/삭제할 수 있습니다." },
                { q: "정렬된 배열에서 중간 값을 기준으로 탐색 범위를 반으로 줄여가며 데이터를 찾는 알고리즘은?", a: ["이진탐색", "이분탐색", "binary search"], exp: "O(log N)의 시간 복잡도를 가지며, 배열이 반드시 정렬되어 있어야 합니다." },
                { q: "최댓값이나 최솟값을 빠르게 찾아내기 위해 고안된 완전 이진 트리 기반의 자료구조는?", a: ["힙", "heap"], exp: "우선순위 큐를 구현할 때 주로 사용됩니다." },
                { q: "문자열을 빠르게 탐색하기 위한 트리 형태의 자료구조로, 자동완성에 주로 쓰이는 것은?", a: ["트라이", "trie"], exp: "문자열 길이가 M일 때 O(M)의 시간복잡도로 탐색할 수 있습니다." },
                { q: "정점(Vertex)과 정점들을 연결하는 간선(Edge)들로 구성된 비선형 자료구조는?", a: ["그래프", "graph"], exp: "방향성이 있을 수도 있고, 순환(Cycle)이 발생할 수도 있습니다." },
                { q: "메모리상에 데이터가 연속적으로 할당되며, 인덱스를 통해 O(1)의 시간에 접근할 수 있는 자료구조는?", a: ["배열", "array"], exp: "탐색은 빠르나, 중간에 데이터를 삽입하거나 삭제할 때는 비효율적입니다." },
                { q: "각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료구조는?", a: ["연결리스트", "linked list", "링크드리스트"], exp: "배열과 달리 메모리가 연속적이지 않으며 데이터 삽입/삭제가 용이합니다." },
                { q: "노드들이 부모-자식 관계로 연결된 계층형 비순환 그래프는?", a: ["트리", "tree"], exp: "최상위 노드를 루트 노드라고 부릅니다." },
                { q: "알고리즘이 문제를 해결하는 데 걸리는 시간(연산 횟수)을 입력 크기에 대한 함수로 나타낸 것은?", a: ["시간복잡도", "time complexity"], exp: "실제 실행 시간이 아닌 연산의 증가 양상을 나타냅니다." },
                { q: "알고리즘의 성능을 수학적으로 표현하는 방법으로, 최악의 경우(Upper Bound)를 표현할 때 사용하는 표기법은?", a: ["빅오표기법", "빅오", "big-o notation", "big-o"], exp: "O(1), O(N), O(N^2) 등으로 나타냅니다." },
                { q: "왼쪽 자식 노드는 부모보다 작고, 오른쪽 자식 노드는 부모보다 큰 값을 가지는 이진 트리는?", a: ["이진탐색트리", "bst", "binary search tree"], exp: "평균 탐색 속도는 O(log N)이나 트리가 편향될 경우 O(N)이 될 수 있습니다." },
                { q: "이진 트리의 순회 방식 중 '루트 -> 왼쪽 자식 -> 오른쪽 자식' 순서로 방문하는 순회는?", a: ["전위순회", "preorder traversal", "preorder"], exp: "트리를 복사하거나 구조를 그대로 출력할 때 유용합니다." },
                { q: "마지막 레벨을 제외한 모든 레벨이 노드로 꽉 차 있고, 마지막 레벨은 왼쪽부터 꽉 차 있는 이진 트리는?", a: ["완전이진트리", "complete binary tree"], exp: "배열을 이용해 효율적으로 저장할 수 있으며 힙(Heap)의 기본 형태입니다." },
                { q: "노드가 삽입/삭제될 때마다 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이가 1 이하가 되도록 회전(Rotation)하여 균형을 맞추는 이진 탐색 트리는?", a: ["avl트리", "avl tree"], exp: "탐색, 삽입, 삭제 모두 엄격하게 O(log N)을 보장합니다." },
                { q: "각 노드에 색상(Red, Black)을 부여하여 트리의 균형을 맞추는 자가 균형 이진 탐색 트리는?", a: ["레드블랙트리", "red black tree", "red-black tree"], exp: "Java의 TreeMap, C++의 map 내부 구현에 주로 쓰입니다." },
                { q: "하나의 노드가 여러 개의 자식(2개 이상)을 가질 수 있으며, 데이터베이스의 인덱스에 주로 사용되는 균형 트리는?", a: ["b트리", "b-tree", "btree"], exp: "디스크 I/O를 최소화하기 위해 고안된 구조입니다." },
                { q: "그래프 탐색 시 큐(Queue)를 사용하여 가까운 정점부터 먼저 방문하는 탐색 알고리즘은?", a: ["너비우선탐색", "bfs", "breadth first search"], exp: "가중치가 없는 그래프에서 최단 경로를 찾을 때 유용합니다." },
                { q: "그래프 탐색 시 스택(Stack)이나 재귀를 사용하여 한 경로를 끝까지 탐색한 후 되돌아오는 알고리즘은?", a: ["깊이우선탐색", "dfs", "depth first search"], exp: "모든 노드를 방문하고자 할 때, 또는 사이클을 검출할 때 유용합니다." },
                { q: "그래프의 모든 정점을 연결하는 부분 그래프 중, 간선의 가중치 합이 가장 작은 트리는?", a: ["최소신장트리", "mst", "minimum spanning tree"], exp: "사이클이 형성되지 않아야 합니다." },
                { q: "간선을 가중치 오름차순으로 정렬한 뒤, 사이클이 발생하지 않는 선에서 간선을 선택해 MST를 만드는 알고리즘은?", a: ["크루스칼알고리즘", "kruskal", "크루스칼"], exp: "사이클 검사를 위해 주로 Union-Find 알고리즘을 함께 사용합니다." },
                { q: "특정 하나의 정점에서 다른 모든 정점까지의 최단 경로를 구하는 알고리즘은? (음수 가중치 불가)", a: ["다익스트라", "dijkstra", "dijkstra algorithm"], exp: "우선순위 큐(힙)를 사용하여 시간 복잡도 O(E log V)를 달성할 수 있습니다." },
                { q: "방향성이 있고 사이클이 없는 그래프(DAG)에서, 정점들의 선후 관계를 위배하지 않도록 순서대로 나열하는 알고리즘은?", a: ["위상정렬", "topological sort"], exp: "선수 과목을 고려한 수강 신청 순서 등을 결정할 때 쓰입니다." },
                { q: "배열에서 가장 작은(또는 큰) 값을 찾아 맨 앞의 데이터와 자리를 교환하며 정렬하는 알고리즘은?", a: ["선택정렬", "selection sort"], exp: "항상 O(N^2)의 시간 복잡도를 가집니다." },
                { q: "두 번째 데이터부터 시작해, 그 앞의 정렬된 부분과 비교하여 자신의 위치를 찾아 삽입하는 정렬 알고리즘은?", a: ["삽입정렬", "insertion sort"], exp: "데이터가 거의 정렬되어 있을 때는 O(N)으로 매우 빠릅니다." },
                { q: "인접한 두 원소를 비교하여 정렬이 되어 있지 않으면 자리를 교환하는 과정을 반복하는 정렬은?", a: ["버블정렬", "bubble sort"], exp: "구현은 쉽지만 성능이 O(N^2)으로 가장 떨어집니다." },
                { q: "피벗(Pivot)을 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 분할하며 정렬하는 분할 정복 알고리즘은?", a: ["퀵정렬", "quick sort"], exp: "평균적으로 가장 빠르며 시간 복잡도는 O(N log N)입니다." },
                { q: "배열을 더 이상 나눌 수 없을 때까지 절반으로 나눈 뒤, 크기를 비교하며 병합하여 정렬하는 알고리즘은?", a: ["병합정렬", "merge sort", "합병정렬"], exp: "안정 정렬(Stable Sort)이며 항상 O(N log N)의 성능을 보장합니다." },
                { q: "들어온 순서와 상관없이 우선순위가 높은 데이터가 먼저 나가는 자료구조는?", a: ["우선순위큐", "priority queue"], exp: "주로 힙(Heap)을 이용하여 구현합니다." },
                { q: "양쪽 끝에서 삽입과 삭제가 모두 가능한 큐의 일종은 무엇인가요?", a: ["덱", "deque", "데크"], exp: "큐와 스택의 특징을 모두 가지고 있습니다." },
                { q: "배열을 이용해 큐를 구현할 때 큐가 가득 차지 않았음에도 공간이 낭비되는 문제를 해결하기 위해 고안된 구조는?", a: ["원형큐", "환형큐", "circular queue"], exp: "rear의 다음 위치가 front와 같아지면 큐가 포화 상태인 것으로 간주합니다." },
                { q: "각 노드가 이전 노드와 다음 노드를 모두 가리키는 포인터를 가지는 연결 리스트는?", a: ["이중연결리스트", "양방향연결리스트", "doubly linked list"], exp: "단방향과 달리 역방향 탐색도 가능합니다." },
                { q: "이진 트리의 순회 방식 중 '왼쪽 자식 -> 루트 -> 오른쪽 자식' 순서로 방문하는 순회는?", a: ["중위순회", "inorder traversal", "inorder"], exp: "이진 탐색 트리(BST)에서 이 방식으로 순회하면 정렬된 결과를 얻습니다." },
                { q: "이진 트리의 순회 방식 중 '왼쪽 자식 -> 오른쪽 자식 -> 루트' 순서로 방문하는 순회는?", a: ["후위순회", "postorder traversal", "postorder"], exp: "자식 노드를 먼저 처리해야 할 때 (예: 디렉토리 용량 계산) 유용합니다." },
                { q: "최소 신장 트리(MST) 알고리즘 중, 임의의 시작 정점에서 출발하여 인접한 간선 중 가중치가 가장 작은 간선을 선택해 나가는 방식은?", a: ["프림알고리즘", "prim", "프림"], exp: "정점 중심의 알고리즘이며 밀집 그래프에서 유리합니다." },
                { q: "그래프 최단 경로 알고리즘 중, 음수 가중치가 있는 그래프에서도 사용할 수 있고 음수 사이클의 존재 여부를 파악할 수 있는 것은?", a: ["벨만포드", "bellman-ford"], exp: "다익스트라보다 느리지만 더 범용적입니다." },
                { q: "모든 정점에서 모든 정점까지의 최단 경로를 한 번에 구하는 3중 for문 기반의 알고리즘은?", a: ["플로이드워셜", "floyd-warshall", "플로이드"], exp: "O(V^3)의 시간복잡도를 가지며 DP 기반입니다." },
                { q: "복잡한 문제를 작은 하위 문제로 나누어 풀고, 그 결과를 저장해 두었다가 재사용하여 실행 속도를 높이는 알고리즘 기법은?", a: ["동적계획법", "dp", "dynamic programming"], exp: "점화식을 세우는 것이 핵심이며, 피보나치 수열 등에 쓰입니다." },
                { q: "동적 계획법에서 동일한 하위 문제의 계산 결과를 메모리에 저장해두고 중복 계산을 방지하는 기법의 명칭은?", a: ["메모이제이션", "memoization"], exp: "주로 재귀(Top-down) 방식에서 사용됩니다." },
                { q: "매 순간마다 당장 눈앞에 보이는 최적의 상황만을 쫓아 최종적인 해답에 도달하는 알고리즘은?", a: ["탐욕알고리즘", "그리디", "greedy"], exp: "항상 최적의 해를 보장하지는 않으므로 정당성 증명이 필요합니다." },
                { q: "모든 가능한 경우의 수를 탐색하되, 진행 경로가 해결책으로 이어지지 않을 것 같으면 더 이상 깊이 가지 않고 되돌아오는(Pruning) 기법은?", a: ["백트래킹", "backtracking", "퇴각검색"], exp: "주로 DFS와 함께 사용되며 스도쿠, N-Queen 문제 등에 쓰입니다." },
                { q: "1차원 배열에서 두 개의 포인터를 조작하여 원하는 조건의 부분 배열이나 값을 O(N)으로 찾아내는 알고리즘 기법은?", a: ["투포인터", "two pointer"], exp: "정렬된 배열에서 두 수의 합을 찾을 때 유용합니다." },
                { q: "배열에서 일정한 크기의 구간(Window)을 유지하며 이동시키면서 특정 조건을 구하는 알고리즘 기법은?", a: ["슬라이딩윈도우", "sliding window"], exp: "연속된 K개의 요소 합의 최댓값을 구할 때 반복 계산을 줄여줍니다." },
                { q: "임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수 또는 그 기법을 무엇이라 하나요?", a: ["해싱", "hashing"], exp: "데이터 검색, 암호화, 무결성 검증 등에 쓰입니다." },
                { q: "서로 다른 두 개의 키가 해시 함수를 거쳐 동일한 해시 값을(인덱스를) 가지게 되는 현상을 무엇이라 하나요?", a: ["해시충돌", "충돌", "collision"], exp: "충돌을 해결하는 기법으로 Chaining, Open Addressing이 있습니다." },
                { q: "해시 충돌 발생 시, 해당 버킷에 연결 리스트(Linked List)를 할당하여 데이터를 뒤이어 저장하는 해결 기법은?", a: ["체이닝", "chaining"], exp: "가장 기본적인 충돌 해결 방법 중 하나입니다." },
                { q: "해시 충돌 발생 시, 연결 리스트를 쓰지 않고 해시 테이블 내의 다른 빈 버킷(Slot)을 찾아 데이터를 저장하는 기법은?", a: ["개방주소법", "open addressing", "오픈어드레싱"], exp: "선형 탐사, 이차 탐사, 이중 해싱 등이 여기에 속합니다." },
                { q: "배열의 맨 앞부터 현재 위치까지의 원소들의 합을 미리 구해 배열에 저장해두고, 특정 구간의 합을 O(1)에 구하는 기법은?", a: ["누적합", "prefix sum"], exp: "배열의 원소가 변하지 않는 경우 구간 합을 구하는 데 매우 효율적입니다." },
                { q: "배열의 원소가 빈번하게 업데이트되는 상황에서, 특정 구간의 합이나 최솟값/최댓값을 O(log N)으로 빠르게 구하기 위한 트리 자료구조는?", a: ["세그먼트트리", "segment tree"], exp: "리프 노드는 배열의 데이터를, 내부 노드는 구간의 정보를 가집니다." }
            ],
            db: [
                { q: "데이터베이스의 상태를 변화시키는 논리적인 작업의 단위는 무엇인가요?", a: ["트랜잭션", "transaction"], exp: "트랜잭션은 작업의 완전성을 보장하기 위해 전부 실행(Commit)되거나 취소(Rollback)되어야 합니다." },
                { q: "트랜잭션이 안전하게 수행되기 위한 4가지 성질(원자성, 일관성, 고립성, 지속성)의 영문 약자는?", a: ["acid"], exp: "데이터베이스 신뢰성의 핵심 요소입니다." },
                { q: "데이터의 중복을 최소화하고 이상 현상(Anomaly)을 방지하기 위해 데이터를 구조화하는 과정은?", a: ["정규화", "normalization"], exp: "무결성을 유지하지만 과도할 경우 JOIN이 많아져 조회 성능이 떨어질 수 있습니다." },
                { q: "데이터베이스 테이블의 검색 속도를 향상시키기 위해 사용하는 별도의 자료구조 객체는?", a: ["인덱스", "index"], exp: "SELECT 성능은 향상되지만 INSERT, UPDATE, DELETE 작업의 성능은 저하될 수 있습니다." },
                { q: "관계형 모델을 사용하지 않고 스키마가 없으며, 수평적 확장이 용이한 데이터베이스 시스템을 통틀어 부르는 말은?", a: ["nosql", "not only sql"], exp: "MongoDB(Document), Redis(Key-Value) 등이 대표적입니다." },
                { q: "두 개 이상의 테이블을 특정 조건에 따라 연결하여 하나의 결과 테이블로 만드는 연산은?", a: ["조인", "join"], exp: "INNER, LEFT OUTER, RIGHT OUTER 조인 등이 있습니다." },
                { q: "실제 데이터를 저장하지 않지만 다른 테이블에서 쿼리된 결과를 기반으로 생성된 가상의 테이블은?", a: ["뷰", "view"], exp: "복잡한 쿼리를 단순화하거나, 특정 데이터만 보여주어 보안을 강화할 때 사용합니다." },
                { q: "테이블 내의 각 레코드를 고유하게 식별할 수 있도록 하는 식별자 역할을 하는 키는?", a: ["기본키", "primary key", "pk"], exp: "기본키는 NULL 값을 가질 수 없으며(NOT NULL) 중복될 수 없습니다(UNIQUE)." },
                { q: "한 테이블의 컬럼 중 다른 테이블의 기본키를 참조하는 컬럼은?", a: ["외래키", "foreign key", "fk"], exp: "테이블 간의 관계를 맺고 참조 무결성을 유지하는 데 사용됩니다." },
                { q: "테이블에 INSERT, UPDATE, DELETE 이벤트가 발생할 때 자동으로 실행되도록 정의해둔 프로그램은?", a: ["트리거", "trigger"], exp: "로그를 남기거나 연관된 테이블의 데이터를 자동으로 동기화할 때 사용합니다." },
                { q: "테이블이나 인덱스 등의 구조를 생성, 변경, 삭제하는 데이터 정의어 명령어 집합의 약자는?", a: ["ddl", "data definition language"], exp: "CREATE, ALTER, DROP, TRUNCATE 등이 속합니다." },
                { q: "데이터베이스 내의 실제 데이터를 삽입, 수정, 삭제, 조회하는 데이터 조작어의 약자는?", a: ["dml", "data manipulation language"], exp: "SELECT, INSERT, UPDATE, DELETE가 속합니다." },
                { q: "데이터베이스의 구조와 제약 조건에 대한 명세(설계도)를 의미하는 용어는?", a: ["스키마", "schema"], exp: "외부, 개념, 내부 스키마로 구성된 3단계 아키텍처를 가집니다." },
                { q: "관계형 데이터베이스의 릴레이션(테이블)에서 데이터의 한 행(Row)을 지칭하는 용어는?", a: ["튜플", "tuple", "레코드"], exp: "튜플의 수를 카디널리티(Cardinality)라고 합니다." },
                { q: "테이블의 튜플을 유일하게 식별할 수 있는 속성들의 집합으로, 유일성과 최소성을 모두 만족하는 키는?", a: ["후보키", "candidate key"], exp: "기본키는 후보키 중에서 선정된 하나의 키입니다." },
                { q: "데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제 값이 일치하는 정확성/일관성을 뜻하는 단어는?", a: ["무결성", "integrity"], exp: "개체, 참조, 도메인 무결성 등이 있습니다." },
                { q: "외래키의 값은 참조하는 테이블의 기본키 값으로 존재해야 하며, 존재하지 않는 값을 참조할 수 없다는 규칙은?", a: ["참조무결성", "referential integrity"], exp: "데이터의 불일치를 방지합니다." },
                { q: "정규화의 첫 단계로, 테이블의 모든 컬럼이 다중 값을 가지지 않고 '원자값(Atomic Value)'만 갖도록 하는 것은?", a: ["제1정규형", "1nf"], exp: "제2정규형은 부분 함수 종속을 제거하는 것입니다." },
                { q: "제3정규형을 만족하면서, 테이블의 모든 결정자가 후보키인 정규형의 영문 약자는?", a: ["bcnf", "boyce codd normal form"], exp: "강한 제3정규형이라고도 불립니다." },
                { q: "정규화된 시스템에서 조회 성능을 향상시키기 위해, 의도적으로 데이터의 중복을 허용하고 통합/분할하는 기법은?", a: ["반정규화", "역정규화", "denormalization"], exp: "무결성이 깨질 위험이 있어 신중하게 적용해야 합니다." },
                { q: "데이터의 중복으로 인해 테이블 조작 시 원하지 않는 데이터가 삭제되거나 삽입할 수 없는 등의 논리적 오류가 발생하는 현상은?", a: ["이상현상", "이상", "anomaly"], exp: "삽입 이상, 삭제 이상, 갱신 이상이 있으며 이를 해결하기 위해 정규화를 합니다." },
                { q: "트랜잭션의 처리가 정상적으로 완료되어, 메모리의 변경 내용을 데이터베이스에 영구적으로 반영하는 연산은?", a: ["커밋", "commit"], exp: "커밋 이후에는 데이터가 복구되지 않는 상태로 저장됩니다." },
                { q: "트랜잭션 처리가 비정상적으로 종료되어, 데이터베이스의 상태를 트랜잭션 시작 이전으로 되돌리는 연산은?", a: ["롤백", "rollback"], exp: "원자성(Atomicity)을 보장하기 위한 수단입니다." },
                { q: "여러 트랜잭션이 동시에 실행될 때, 서로 얼마나 고립되어 있는지(영향을 미치지 않는지)를 나타내는 수준은?", a: ["격리수준", "isolation level", "고립수준"], exp: "Read Uncommitted부터 Serializable까지 4단계가 있습니다." },
                { q: "트랜잭션이 데이터를 읽을 때 설정하며, 다른 트랜잭션도 읽기는 가능하지만 쓰기는 불가능하게 막는 락(Lock)은?", a: ["공유락", "shared lock", "s-lock"], exp: "데이터 쓰기를 할 때는 배타락(Exclusive Lock)을 사용합니다." },
                { q: "두 트랜잭션이 서로가 점유하고 있는 락(Lock)의 해제를 무한정 기다리며 진행이 멈추는 현상은?", a: ["데드락", "교착상태", "deadlock"], exp: "이를 해결하기 위해 락 타임아웃이나 데드락 감지 알고리즘을 사용합니다." },
                { q: "데이터베이스 인덱스에서 가장 광범위하게 사용되는, 모든 리프 노드가 같은 깊이를 가지는 균형 트리 구조는?", a: ["b-tree", "b tree", "btree"], exp: "일반적으로 범위 검색에 최적화된 B+Tree 변형을 많이 씁니다." },
                { q: "테이블의 데이터 자체가 인덱스의 순서대로 물리적으로 정렬되어 저장되는 인덱스 방식은?", a: ["클러스터형인덱스", "클러스터인덱스", "clustered index"], exp: "테이블당 1개만 생성할 수 있으며 검색 속도가 매우 빠릅니다." },
                { q: "여러 SQL 쿼리를 논리적인 작업 단위로 묶어서 데이터베이스 서버에 미리 컴파일해 저장해둔 객체는?", a: ["프로시저", "저장프로시저", "stored procedure"], exp: "네트워크 트래픽을 줄이고 처리 성능을 높일 수 있습니다." },
                { q: "객체지향 언어의 객체(Object)와 관계형 DB의 테이블(Relation)을 자동으로 연결(매핑)해주는 프레임워크나 기법의 약자는?", a: ["orm", "object relational mapping"], exp: "SQL을 직접 작성하지 않아도 DB를 조작할 수 있게 해줍니다. (예: JPA, Hibernate)" },
                { q: "데이터베이스 사용자에게 권한을 부여하거나 회수하는 데이터 제어어 명령어 집합의 약자는?", a: ["dcl", "data control language"], exp: "GRANT와 REVOKE가 여기에 속합니다." },
                { q: "트랜잭션을 제어하기 위해 사용하는 명령어 집합의 약자는?", a: ["tcl", "transaction control language"], exp: "COMMIT, ROLLBACK, SAVEPOINT 등이 있습니다." },
                { q: "관계형 데이터베이스에서 원하는 데이터를 유도하기 위해 연산자와 연산 규칙을 제공하는 절차적 언어 체계는?", a: ["관계대수", "relational algebra"], exp: "선택(Select), 투영(Project), 조인(Join) 등의 연산이 있습니다." },
                { q: "조인 조건이 없는 두 테이블의 모든 가능한 행의 조합을 반환하는 교차 조인(Cross Join)의 다른 수학적 명칭은?", a: ["카테시안곱", "cartesian product"], exp: "결과 행의 수는 두 테이블의 행을 곱한 것과 같습니다." },
                { q: "하나의 테이블 내에서 자신과 자신을 조인하여 계층적인 데이터나 관계를 조회할 때 사용하는 조인은?", a: ["셀프조인", "self join"], exp: "직원의 매니저 정보를 같은 테이블에서 찾을 때 주로 씁니다." },
                { q: "조인 조건을 만족하지 않는 행도 결과에 포함시키는 조인 방식으로, LEFT, RIGHT, FULL로 나뉘는 이것은?", a: ["외부조인", "아우터조인", "outer join"], exp: "일치하지 않는 컬럼의 값은 NULL로 채워집니다." },
                { q: "하나의 SQL 문장 안에 포함된 또 다른 SELECT 문장으로, 괄호()로 묶어서 사용하는 것은?", a: ["서브쿼리", "subquery", "하위쿼리"], exp: "SELECT 절, FROM 절(인라인 뷰), WHERE 절 등에 위치할 수 있습니다." },
                { q: "SQL에서 특정 속성을 기준으로 그룹화하여 집계 함수(COUNT, SUM 등)를 적용할 때 사용하는 절은?", a: ["group by", "groupby"], exp: "부서별 평균 급여 등을 계산할 때 필수적입니다." },
                { q: "GROUP BY 절에 의해 생성된 그룹 중에서 특정 조건을 만족하는 그룹만 필터링할 때 사용하는 절은?", a: ["having", "having절"], exp: "WHERE 절은 그룹화하기 전의 개별 행을 필터링하고, HAVING은 그룹화 후의 결과를 필터링합니다." },
                { q: "In-Memory 기반의 Key-Value 구조로 데이터를 저장하며, 캐싱 시스템으로 널리 쓰이는 오픈소스 NoSQL DB는?", a: ["redis", "레디스"], exp: "속도가 매우 빠르며 다양한 자료구조(List, Set 등)를 지원합니다." },
                { q: "분산 데이터베이스 시스템은 일관성(Consistency), 가용성(Availability), 분할 내성(Partition tolerance) 세 가지 중 두 가지만 만족할 수 있다는 정리(Theorem)는?", a: ["cap정리", "cap theorem", "cap"], exp: "완벽한 분산 시스템 설계의 제약 사항을 나타냅니다." },
                { q: "ACID와 대조되는 개념으로, NoSQL 시스템에서 데이터의 가용성을 중시하여 어느 정도의 일관성 지연(Eventual Consistency)을 허용하는 특성은?", a: ["base"], exp: "Basically Available, Soft state, Eventual consistency의 약자입니다." },
                { q: "하나의 거대한 데이터베이스 테이블을 행(Row) 단위로 나누어 여러 대의 데이터베이스 서버에 분산 저장하는 기술은?", a: ["샤딩", "sharding"], exp: "수평 파티셔닝(Horizontal Partitioning)의 일종으로 트래픽을 분산시킵니다." },
                { q: "큰 테이블을 성능 향상이나 관리를 위해 더 작은 논리적 단위로 나누는 데이터베이스 설계 기법은?", a: ["파티셔닝", "partitioning"], exp: "수직(Vertical) 파티셔닝과 수평(Horizontal) 파티셔닝이 있습니다." },
                { q: "애플리케이션이 DB와 연결을 맺는 비용을 줄이기 위해, 미리 일정 개수의 커넥션을 만들어두고 재사용하는 기법은?", a: ["커넥션풀", "connection pool"], exp: "DB 서버의 부하를 줄이고 응답 속도를 향상시킵니다." },
                { q: "사용자의 입력값을 조작하여 의도하지 않은 악의적인 SQL 문이 데이터베이스에서 실행되게 하는 해킹 공격 기법은?", a: ["sql인젝션", "sql injection"], exp: "Prepared Statement(바인딩) 등을 사용하여 방어할 수 있습니다." },
                { q: "DBMS의 옵티마이저가 SQL 쿼리를 실행하기 위해 수립한 최적의 실행 경로와 방법이 담긴 계획은?", a: ["실행계획", "execution plan"], exp: "쿼리 튜닝 시 가장 먼저 확인해야 하는 정보입니다." },
                { q: "데이터베이스 구조, 제약 조건, 인덱스 정보 등 '데이터에 대한 데이터'를 무엇이라 하나요?", a: ["메타데이터", "metadata"], exp: "시스템 카탈로그나 데이터 사전(Data Dictionary)에 저장됩니다." },
                { q: "데이터베이스의 스키마 구조, 사용자 권한 정보 등 시스템 관리에 필요한 모든 메타데이터가 저장되는 시스템 테이블의 집합은?", a: ["데이터사전", "data dictionary", "시스템카탈로그"], exp: "일반 사용자는 주로 읽기만 가능합니다." },
                { q: "여러 트랜잭션이 동시에 실행될 때 데이터의 일관성을 유지하기 위해 데이터 접근을 제어하는 기법은?", a: ["동시성제어", "concurrency control"], exp: "동시성 제어가 제대로 되지 않으면 갱신 분실, 모순성 등의 문제가 발생합니다." }
            ],
            architecture: [
                { q: "CPU와 주기억장치 간의 속도 차이를 극복하기 위해 사용되는 고속의 메모리는?", a: ["캐시메모리", "캐시", "cache memory"], exp: "캐시는 지역성의 원리를 이용하여 자주 사용하는 데이터를 저장해 둡니다." },
                { q: "CPU 내부에 존재하는 가장 빠르고 작은 크기의 임시 기억장치는?", a: ["레지스터", "register"], exp: "CPU가 명령어 연산에 필요한 데이터를 일시적으로 저장합니다." },
                { q: "하나의 명령어가 실행되는 도중 다음 명령어의 실행을 시작하여 처리량을 높이는 병렬 처리 기법은?", a: ["파이프라이닝", "파이프라인", "pipelining"], exp: "IF-ID-EX-MEM-WB 등 여러 단계로 나누어 명령어들을 중첩 실행합니다." },
                { q: "CPU 내부에서 덧셈/뺄셈 등의 산술 연산과 AND/OR 등의 논리 연산을 수행하는 핵심 장치의 영문 약자는?", a: ["alu", "arithmetic logic unit", "산술논리연산장치"], exp: "ALU는 제어장치의 지시에 따라 실제 계산을 수행합니다." },
                { q: "입출력 장치가 CPU를 거치지 않고 메인 메모리에 직접 접근하여 데이터를 대량으로 전송하는 기술의 약자는?", a: ["dma", "direct memory access"], exp: "CPU의 개입을 줄여 시스템의 전반적인 효율을 크게 높입니다." },
                { q: "복잡하고 다양한 길이의 명령어 세트를 가지며 컴파일러 작성이 쉬운 구조의 CPU 아키텍처는? (Intel x86 등)", a: ["cisc", "complex instruction set computer"], exp: "명령어가 복잡하여 전력 소모가 큽니다." },
                { q: "명령어의 종류와 길이를 고정하고 단순화하여 파이프라이닝 효율을 극대화한 CPU 아키텍처는? (ARM 등)", a: ["risc", "reduced instruction set computer"], exp: "모바일 기기 등에서 전력 효율과 성능을 높이기 위해 주로 사용합니다." },
                { q: "프로그램(명령어)과 데이터를 모두 같은 메모리 공간에 저장하여 순차적으로 실행하는 컴퓨터 아키텍처는?", a: ["폰노이만구조", "폰노이만", "von neumann"], exp: "명령어와 데이터가 같은 버스를 사용하여 병목 현상(폰노이만 병목)이 발생할 수 있습니다." },
                { q: "메모리에 여러 바이트의 데이터를 저장할 때, 순서대로 낮은 주소부터 채울지(리틀), 높은 주소부터 채울지(빅)를 결정하는 방식은?", a: ["엔디안", "엔디언", "endian", "endianness"], exp: "네트워크 통신은 기본적으로 빅 엔디안 방식을 사용합니다." },
                { q: "명령어의 해석과 실행을 지시하기 위해 시스템의 모든 동작을 통제하고 타이밍 신호를 발생시키는 CPU 내부 장치는?", a: ["제어장치", "cu", "control unit"], exp: "ALU, 레지스터, 메모리 등에 제어 신호를 보냅니다." },
                { q: "CPU가 다음번에 실행할 명령어의 메모리 주소를 기억하고 있는 레지스터의 영문 약자는?", a: ["pc", "program counter", "프로그램카운터"], exp: "명령어를 하나 인출할 때마다 자동으로 값이 증가합니다." },
                { q: "메모리에서 읽어온 명령어의 코드를 해독하기 위해 잠시 보관하는 레지스터의 영문 약자는?", a: ["ir", "instruction register", "명령어레지스터"], exp: "제어장치가 이 레지스터의 값을 해독하여 제어 신호를 생성합니다." },
                { q: "명령어 사이클 중, 메모리에서 명령어를 읽어 CPU 내부의 레지스터(IR)로 가져오는 단계는?", a: ["인출사이클", "fetch cycle", "인출"], exp: "인출, 간접, 실행, 인터럽트 사이클 중 가장 첫 번째 단계입니다." },
                { q: "CPU, 메모리, 입출력 장치들이 데이터를 주고받기 위해 사용하는 물리적인 통신 회선들의 집합은?", a: ["버스", "bus", "시스템버스"], exp: "용도에 따라 데이터, 주소, 제어 버스로 나뉩니다." },
                { q: "CPU가 읽거나 쓰려는 메모리나 I/O 장치의 위치(번지) 정보를 전달하는 단방향 버스는?", a: ["주소버스", "address bus"], exp: "주소 버스의 폭(비트 수)이 컴퓨터가 인식할 수 있는 최대 메모리 용량을 결정합니다." },
                { q: "컴퓨터 부품들이 타이밍을 맞춰 동작할 수 있도록 주기적으로 발생하는 전기적 진동 신호는?", a: ["클럭", "clock", "클럭신호"], exp: "클럭 주파수(Hz)가 높을수록 CPU 처리 속도가 일반적으로 빠릅니다." },
                { q: "CPU 내부에 여러 개의 파이프라인(ALU 등)을 두어, 한 클럭 사이클에 여러 명령어를 동시에 실행하는 기법은?", a: ["슈퍼스칼라", "superscalar"], exp: "현대 CPU 아키텍처의 성능 향상을 위한 핵심 기술입니다." },
                { q: "조건 분기(If문 등) 명령어에서 어느 쪽으로 분기할지 미리 예측하여 파이프라인의 끊김을 최소화하는 하드웨어 기술은?", a: ["분기예측", "branch prediction"], exp: "예측에 실패하면 실행 중이던 파이프라인을 비워야(Flush) 합니다." },
                { q: "파이프라이닝에서 명령어들의 의존성이나 자원 부족으로 인해 다음 명령어를 즉시 실행하지 못하고 멈추어야 하는 상황은?", a: ["해저드", "hazard"], exp: "구조적, 데이터, 제어 해저드 3종류가 있습니다." },
                { q: "데이터 해저드를 해결하기 위해 앞 명령어의 연산 결과를 레지스터에 쓰기 전에 다음 명령어의 입력으로 바로 넘겨주는 기법은?", a: ["데이터포워딩", "포워딩", "data forwarding"], exp: "파이프라인이 멈추는(Stall) 현상을 줄여줍니다." },
                { q: "프로그램이 기억장치의 특정 부분만 집중적으로 참조하는 경향성을 의미하는 용어는?", a: ["지역성", "국부성", "locality"], exp: "시간적 지역성과 공간적 지역성이 있으며 캐시 메모리의 기초 이론입니다." },
                { q: "메인 메모리의 블록이 캐시 메모리의 특정 지정된 한 위치(라인)에만 들어갈 수 있는 매핑 방식은?", a: ["직접사상", "direct mapping", "직접매핑"], exp: "구현이 간단하고 검색이 빠르지만 충돌(Conflict)이 잦습니다." },
                { q: "CPU가 찾는 데이터가 캐시 메모리에 존재하지 않아 메인 메모리에서 가져와야 하는 상황은?", a: ["캐시미스", "cache miss"], exp: "미스가 발생하면 프로세서가 멈추고 지연(Penalty)이 발생합니다." },
                { q: "전원이 꺼지면 저장된 내용이 모두 지워지는 휘발성 메모리로, 컴퓨터의 주기억장치로 사용되는 것은?", a: ["ram", "random access memory", "램"], exp: "DRAM과 SRAM으로 나뉩니다." },
                { q: "전원이 꺼져도 내용이 보존되는 비휘발성 메모리로, 주로 바이오스(BIOS)나 펌웨어 저장에 사용되는 것은?", a: ["rom", "read only memory", "롬"], exp: "한 번 쓰면 지울 수 없는 Mask ROM, 지우고 쓸 수 있는 EEPROM 등이 있습니다." },
                { q: "전력이 끊겨도 데이터를 유지하는 비휘발성 반도체 메모리로, SSD나 스마트폰 저장장치에 널리 쓰이는 것은?", a: ["플래시메모리", "flash memory"], exp: "NAND형과 NOR형으로 나뉩니다." },
                { q: "하드디스크에서 탐색 시간(Seek Time)을 최소화하기 위해 읽기/쓰기 헤드의 이동 경로를 최적화하는 기법은?", a: ["디스크스케줄링", "disk scheduling"], exp: "FCFS, SSTF, SCAN, C-SCAN 알고리즘 등이 있습니다." },
                { q: "여러 개의 물리적 디스크를 논리적인 하나의 디스크처럼 구성하여 데이터의 안정성 향상 및 병렬 처리를 꾀하는 기술은?", a: ["raid"], exp: "미러링(RAID 1), 패리티 사용(RAID 5) 등의 방식이 있습니다." },
                { q: "CPU가 입출력 장치의 상태를 지속적으로 확인하여 데이터 전송 준비가 되었는지 검사하는 소프트웨어적인 입출력 방식은?", a: ["폴링", "polling"], exp: "인터럽트 방식에 비해 CPU 자원 낭비가 심합니다." },
                { q: "명령어 메모리와 데이터 메모리를 물리적으로 분리하고 각각의 버스를 사용하여 폰노이만 병목을 개선한 아키텍처는?", a: ["하버드구조", "하버드아키텍처", "harvard architecture"], exp: "현대의 CPU는 내부에 캐시를 분리(L1 명령어 캐시, L1 데이터 캐시)하여 이 구조를 차용하고 있습니다." },
                { q: "메모리에서 읽거나 쓸 데이터의 실제 물리적 '주소'를 기억하는 레지스터의 약자는?", a: ["mar", "memory address register"], exp: "이 레지스터의 값은 주소 버스를 통해 메모리로 전달됩니다." },
                { q: "메모리에서 읽어온 '데이터'나 메모리에 쓸 '데이터'를 임시로 보관하는 레지스터의 약자는?", a: ["mbr", "mdr", "memory buffer register", "memory data register"], exp: "데이터 버스와 직접 연결되어 있습니다." },
                { q: "명령어 레지스터(IR)에 있는 명령어 코드를 받아들여 해당하는 제어 신호를 생성하는 논리 회로는?", a: ["디코더", "해독기", "decoder"], exp: "N개의 입력 선을 받아 최대 2^N개의 출력 선 중 하나를 활성화합니다." },
                { q: "디코더의 반대 역할을 수행하며, 2^N개의 입력 선 중 하나에 신호가 주어지면 N개의 출력 선으로 이진 코드를 만들어 내는 회로는?", a: ["인코더", "부호기", "encoder"], exp: "주로 사용자 입력을 컴퓨터가 인식할 수 있는 코드로 변환할 때 쓰입니다." },
                { q: "여러 개의 데이터 입력 선 중에서 하나를 선택하여 단일 출력 선으로 연결하는 논리 회로는?", a: ["멀티플렉서", "multiplexer", "mux"], exp: "'데이터 선택기'라고도 불립니다." },
                { q: "컴퓨터의 메모리 중 1비트의 정보를 저장할 수 있는 기본 논리 회로 단위는?", a: ["플립플롭", "flip flop", "flip-flop"], exp: "레지스터와 SRAM의 기본 구성 요소로 사용됩니다." },
                { q: "플립플롭으로 구성되어 전원이 공급되는 동안 내용을 유지하며, 속도가 빨라 캐시 메모리에 사용되는 RAM은?", a: ["sram", "static ram"], exp: "주기적인 재충전(Refresh)이 필요 없습니다." },
                { q: "커패시터(축전기)에 전하를 저장하여 데이터를 유지하며, 방전되기 때문에 주기적인 재충전(Refresh)이 필요한 RAM은?", a: ["dram", "dynamic ram"], exp: "구조가 간단하고 집적도가 높아 PC의 메인 메모리(주기억장치)로 널리 쓰입니다." },
                { q: "자기 디스크(HDD)를 대체하기 위해 플래시 메모리를 사용하여 만든 대용량 보조기억장치는?", a: ["ssd", "solid state drive"], exp: "물리적으로 움직이는 부품이 없어 소음이 없고 속도가 훨씬 빠릅니다." },
                { q: "자성 물질이 코팅된 플래터(원판)를 회전시키며 헤드를 통해 데이터를 읽고 쓰는 전통적인 보조기억장치의 약자는?", a: ["hdd", "hard disk drive", "하드디스크"], exp: "탐색 시간(Seek Time)과 회전 지연 시간(Rotational Latency)이 속도의 병목이 됩니다." },
                { q: "명령어를 실행하기 위해 CPU 내부에서 일어나는 가장 기본적이고 세밀한 단위 동작을 무엇이라 하나요?", a: ["마이크로오퍼레이션", "마이크로연산", "micro-operation"], exp: "하나의 클럭 펄스 동안 실행되는 레지스터 간의 데이터 이동 등이 여기에 속합니다." },
                { q: "명령어 사이클 중, 현재 실행 중인 프로그램의 실행을 멈추고 상태를 보관한 뒤 처리 루틴으로 분기하는 단계는?", a: ["인터럽트사이클", "interrupt cycle"], exp: "명령어 실행(Execute) 사이클이 끝난 후 인터럽트 요청이 있는지 검사합니다." },
                { q: "CPU가 메모리에서 하나의 명령어를 인출하여 디코딩하고 실행하는 전체 과정을 통틀어 이르는 말은?", a: ["명령어사이클", "instruction cycle", "기계주기"], exp: "인출, 간접, 실행, 인터럽트 사이클로 구성됩니다." },
                { q: "CPU 코어 내부에 존재하며 속도가 가장 빠른 1차 캐시 메모리의 약자는?", a: ["l1캐시", "l1 cache", "level 1 cache"], exp: "보통 명령어 캐시와 데이터 캐시로 물리적으로 분리되어(하버드 구조) 있습니다." },
                { q: "캐시 메모리 쓰기 정책 중, 데이터가 변경될 때 캐시와 메인 메모리를 동시에 업데이트하여 일관성을 즉시 유지하는 방식은?", a: ["직접쓰기", "write through", "write-through"], exp: "구현이 쉽고 데이터 손실 위험이 적으나, 메모리 접근 횟수가 많아 쓰기 속도가 느립니다." },
                { q: "캐시 메모리 쓰기 정책 중, 캐시의 데이터만 먼저 업데이트하고 나중에 캐시 블록이 교체될 때 한꺼번에 메인 메모리에 기록하는 방식은?", a: ["지연쓰기", "write back", "write-back"], exp: "메모리 접근 횟수를 줄여 속도가 빠르지만, 전원 차단 시 데이터 유실 위험이 있습니다." },
                { q: "멀티프로세서 시스템에서, 프로세서가 자신에게 가까운 로컬 메모리에 접근할 때와 다른 프로세서의 원격 메모리에 접근할 때의 속도가 다른 아키텍처는?", a: ["numa", "non uniform memory access"], exp: "UMA 구조의 확장성 한계를 극복하기 위해 등장했습니다." },
                { q: "두 개 이상의 똑같은 프로세서가 하나의 메인 메모리와 운영체제를 공유하는 대칭형 다중 처리 구조의 약자는?", a: ["smp", "symmetric multiprocessor"], exp: "현대의 대부분의 멀티코어 PC가 채택하고 있는 방식입니다." },
                { q: "CPU와 달리 수천 개의 단순한 코어로 구성되어 병렬 처리에 특화되었으며, 주로 그래픽 처리나 AI 연산에 사용되는 장치는?", a: ["gpu", "graphics processing unit"], exp: "대량의 단순 연산을 동시에 처리하는 데 압도적인 성능을 보입니다." },
                { q: "구글에서 개발한 머신러닝 전용 하드웨어로, 텐서플로우 연산을 가속화하기 위해 만들어진 AI 가속기(ASIC)의 약자는?", a: ["tpu", "tensor processing unit"], exp: "딥러닝의 행렬 곱셈 연산에 극도로 최적화되어 있습니다." }
            ]
        };

        // --- 1-1. DB 초기화 (상태 관리용 속성 부여 및 로컬 스토리지 연동) ---
        function initDB() {
            const savedData = JSON.parse(localStorage.getItem('csQuizProgress')) || { solved: [], bookmarked: [] };

            for (const [cat, questions] of Object.entries(quizDB)) {
                questions.forEach((q, idx) => {
                    q.id = `${cat}_${idx}`;
                    q.categoryId = cat;
                    q.solved = savedData.solved.includes(q.id);
                    q.bookmarked = savedData.bookmarked.includes(q.id);
                });
            }
        }

        // --- 상태 저장 함수 (로컬 스토리지에 진행률 저장) ---
        function saveData() {
            const progressData = {
                solved: [],
                bookmarked: []
            };

            for (const questions of Object.values(quizDB)) {
                questions.forEach(q => {
                    if (q.solved) progressData.solved.push(q.id);
                    if (q.bookmarked) progressData.bookmarked.push(q.id);
                });
            }
            
            localStorage.setItem('csQuizProgress', JSON.stringify(progressData));
        }

        const categoryInfo = {
            os: { name: "운영체제 (OS)", icon: "fa-laptop-code", color: "text-blue-400" },
            network: { name: "네트워크", icon: "fa-network-wired", color: "text-green-400" },
            datastructure: { name: "자료구조 & 알고리즘", icon: "fa-sitemap", color: "text-purple-400" },
            db: { name: "데이터베이스", icon: "fa-database", color: "text-yellow-400" },
            architecture: { name: "컴퓨터 구조", icon: "fa-microchip", color: "text-red-400" }
        };

        // --- 2. 상태 관리 ---
        let state = {
            quizMode: 'category', // 'category', 'random', 'bookmark'
            currentCategory: null,
            questions: [],
            currentIndex: 0,
            score: 0,
            hasAnswered: false
        };

        const appDiv = document.getElementById('app');

        // --- 커스텀 모달 및 알림 UI 함수 (alert, confirm 대체) ---
        function showModal(message, onConfirm) {
            const modalHtml = `
                <div id="customModal" class="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50 fade-in">
                    <div class="bg-slate-800 p-6 rounded-2xl shadow-2xl border border-slate-700 max-w-sm w-full mx-4">
                        <h3 class="text-xl font-bold mb-4 text-white">확인</h3>
                        <p class="text-slate-300 mb-6 break-keep">${message}</p>
                        <div class="flex justify-end gap-3">
                            <button id="modalCancel" class="px-4 py-2 rounded-lg bg-slate-700 hover:bg-slate-600 text-white transition">취소</button>
                            <button id="modalConfirm" class="px-4 py-2 rounded-lg bg-blue-600 hover:bg-blue-700 text-white transition">확인</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', modalHtml);

            document.getElementById('modalCancel').onclick = () => {
                document.getElementById('customModal').remove();
            };

            document.getElementById('modalConfirm').onclick = () => {
                document.getElementById('customModal').remove();
                if(onConfirm) onConfirm();
            };
        }

        function showAlert(message, callback) {
            const modalHtml = `
                <div id="customAlert" class="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50 fade-in">
                    <div class="bg-slate-800 p-6 rounded-2xl shadow-2xl border border-slate-700 max-w-sm w-full mx-4 text-center">
                        <div class="text-emerald-400 text-4xl mb-4"><i class="fas fa-check-circle"></i></div>
                        <p class="text-slate-300 mb-6 break-keep">${message}</p>
                        <button id="alertOk" class="px-6 py-2 rounded-lg bg-blue-600 hover:bg-blue-700 text-white transition w-full">확인</button>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', modalHtml);

            document.getElementById('alertOk').onclick = () => {
                document.getElementById('customAlert').remove();
                if(callback) callback();
            };
        }

        // --- 3. 유틸리티 함수 ---
        function shuffle(array) {
            let currentIndex = array.length, randomIndex;
            while (currentIndex !== 0) {
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;
                [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
            }
            return array;
        }

        function getQuestionById(id) {
            const [cat, idx] = id.split('_');
            return quizDB[cat][idx];
        }

        // --- 4. 뷰 렌더링 함수 ---

        // 홈 화면 렌더링
        function renderHome() {
            let categoryHTML = '';
            let totalQuestions = 0;
            let totalSolved = 0;
            let totalBookmarked = 0;

            for (const [key, info] of Object.entries(categoryInfo)) {
                const qs = quizDB[key];
                const catTotal = qs.length;
                const catSolved = qs.filter(q => q.solved).length;
                
                totalQuestions += catTotal;
                totalSolved += catSolved;
                totalBookmarked += qs.filter(q => q.bookmarked).length;

                const progress = catTotal === 0 ? 0 : (catSolved / catTotal) * 100;
                const isResetDisabled = catSolved === 0;

                categoryHTML += `
                    <div onclick="startCategoryQuiz('${key}')" class="bg-slate-700 rounded-xl border border-slate-600 overflow-hidden flex flex-col transition hover:border-slate-500 cursor-pointer group hover:-translate-y-1 hover:shadow-lg">
                        <div class="p-4 flex items-center justify-between bg-slate-700/80">
                            <div class="flex items-center gap-3">
                                <div class="w-10 h-10 flex items-center justify-center rounded-lg bg-slate-800 shadow-inner transition group-hover:scale-110">
                                    <i class="fas ${info.icon} ${info.color}"></i>
                                </div>
                                <div>
                                    <h3 class="font-bold text-base text-slate-100">${info.name}</h3>
                                    <p class="text-xs text-slate-400 mt-0.5">${catSolved} / ${catTotal} 완료</p>
                                </div>
                            </div>
                            <button onclick="event.stopPropagation(); ${isResetDisabled ? '' : `resetCategorySolved('${key}')`}" class="p-2 rounded transition ${isResetDisabled ? 'text-slate-600 cursor-not-allowed' : 'text-slate-400 hover:text-rose-400 hover:bg-slate-600'}" title="이 분야 초기화" ${isResetDisabled ? 'disabled' : ''}>
                                <i class="fas fa-undo"></i>
                            </button>
                        </div>
                    </div>
                `;
            }

            appDiv.innerHTML = `
                <div class="p-6 md:p-8 fade-in">
                    <div class="text-center mb-8">
                        <h1 class="text-2xl md:text-3xl font-extrabold mb-3 text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-500">
                            CS Master
                        </h1>
                        <p class="text-slate-400 text-sm md:text-base font-medium">IT 취준생을 위한 CS 지식 퀴즈</p>
                    </div>

                    <!-- 글로벌 액션 버튼 -->
                    <div class="flex flex-wrap gap-3 mb-8 justify-center">
                        <button onclick="startRandomQuiz()" class="flex-1 min-w-[120px] py-3.5 bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-500 hover:to-indigo-500 text-white rounded-xl text-sm font-bold transition shadow-lg shadow-purple-600/20">
                            <i class="fas fa-random mr-1.5"></i> 랜덤 (전체)
                        </button>
                        <button onclick="startBookmarkQuiz()" class="flex-1 min-w-[120px] py-3.5 bg-gradient-to-r from-yellow-600 to-orange-600 hover:from-yellow-500 hover:to-orange-500 text-white rounded-xl text-sm font-bold transition shadow-lg shadow-yellow-600/20">
                            <i class="fas fa-star mr-1.5"></i> 북마크 (${totalBookmarked})
                        </button>
                        <button onclick="renderSolvedList()" class="flex-1 min-w-[120px] py-3.5 bg-gradient-to-r from-emerald-600 to-teal-600 hover:from-emerald-500 hover:to-teal-500 text-white rounded-xl text-sm font-bold transition shadow-lg shadow-emerald-600/20">
                            <i class="fas fa-check-circle mr-1.5"></i> 해결한 문제
                        </button>
                    </div>

                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-8">
                        ${categoryHTML}
                    </div>

                    <div class="text-center">
                        <button onclick="${totalSolved === 0 ? '' : 'resetAllSolved()'}" class="text-sm transition ${totalSolved === 0 ? 'text-slate-600 cursor-not-allowed' : 'text-slate-500 hover:text-rose-400 underline underline-offset-4'}" ${totalSolved === 0 ? 'disabled' : ''}>
                            모든 분야 풀이 기록 초기화
                        </button>
                    </div>
                </div>
            `;
        }

        // 해결한 문제 목록 화면
        function renderSolvedList() {
            let listHTML = '';
            let hasSolved = false;

            for (const [key, info] of Object.entries(categoryInfo)) {
                // 진입 시점에 해결 상태인 문제만 필터링 (렌더링 이후 상태가 바뀌어도 즉시 사라지지 않음)
                const solvedQs = quizDB[key].filter(q => q.solved);
                
                if (solvedQs.length > 0) {
                    hasSolved = true;
                    listHTML += `
                        <div class="mb-6">
                            <h3 class="font-bold text-base mb-3 flex items-center gap-2 ${info.color}">
                                <i class="fas ${info.icon}"></i> ${info.name}
                            </h3>
                            <div class="flex flex-col gap-2">
                                ${solvedQs.map(q => `
                                    <div onclick="toggleSolvedStateUI('${q.id}')" class="cursor-pointer flex items-center gap-3 p-3 bg-slate-700/40 hover:bg-slate-700 rounded-lg border border-slate-600 transition group">
                                        <div id="solved-btn-${q.id}" class="flex-shrink-0 w-6 h-6 rounded border bg-blue-500 border-blue-500 text-white flex items-center justify-center transition group-hover:scale-110" title="상태 변경">
                                            <i class="fas fa-check text-xs"></i>
                                        </div>
                                        <div id="solved-text-${q.id}" class="flex-grow text-sm text-slate-200 line-clamp-2 pr-2 transition-all">
                                            ${q.q}
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }
            }

            appDiv.innerHTML = `
                <div class="p-6 md:p-8 fade-in flex flex-col h-[80vh] min-h-[500px]">
                    <div class="flex justify-between items-center mb-6">
                        <button onclick="renderHome()" class="text-slate-400 hover:text-white transition flex items-center gap-2">
                            <i class="fas fa-arrow-left"></i> 홈으로 (ESC)
                        </button>
                        <div class="flex items-center gap-2">
                            <i class="fas fa-check-circle text-emerald-400"></i>
                            <span class="font-bold">해결한 문제 목록</span>
                        </div>
                    </div>

                    <div class="flex-grow overflow-y-auto pr-2">
                        ${hasSolved ? listHTML : '<div class="h-full flex flex-col items-center justify-center text-slate-500"><i class="fas fa-inbox text-4xl mb-4 text-slate-600"></i><p>아직 해결한 문제가 없습니다.</p></div>'}
                    </div>
                </div>
            `;
        }

        // 해결한 문제 목록에서 상태 토글 (화면에서 즉시 사라지지 않고 스타일만 변경)
        function toggleSolvedStateUI(id) {
            const q = getQuestionById(id);
            q.solved = !q.solved; // 상태 반전

            const btn = document.getElementById(`solved-btn-${id}`);
            const text = document.getElementById(`solved-text-${id}`);

            if (q.solved) {
                // 다시 체크된 상태
                btn.className = "flex-shrink-0 w-6 h-6 rounded border bg-blue-500 border-blue-500 text-white flex items-center justify-center transition group-hover:scale-110";
                text.classList.remove("text-slate-500", "line-through");
                text.classList.add("text-slate-200");
            } else {
                // 체크 해제된 상태 (UI만 흐리게 변경, 취소선 제거)
                btn.className = "flex-shrink-0 w-6 h-6 rounded border bg-slate-800 border-slate-500 text-transparent flex items-center justify-center transition group-hover:scale-110";
                text.classList.remove("text-slate-200", "line-through");
                text.classList.add("text-slate-500");
            }
            
            saveData(); // 상태 변경 후 로컬 스토리지에 저장
        }

        // --- 기록 초기화 기능 ---
        const RESET_CONFIRM_MSG = '풀이 기록(체크)을 초기화하시겠습니까? (북마크는 유지됩니다)';
        const RESET_SUCCESS_MSG = '풀이 기록이 성공적으로 초기화되었습니다.';

        function resetAllSolved() {
            showModal(RESET_CONFIRM_MSG, () => {
                for (const cat in quizDB) {
                    quizDB[cat].forEach(q => q.solved = false);
                }
                saveData(); // 초기화 후 로컬 스토리지에 저장
                showAlert(RESET_SUCCESS_MSG, () => {
                    renderHome();
                });
            });
        }

        function resetCategorySolved(cat) {
            showModal(RESET_CONFIRM_MSG, () => {
                quizDB[cat].forEach(q => q.solved = false);
                saveData(); // 초기화 후 로컬 스토리지에 저장
                showAlert(RESET_SUCCESS_MSG, () => {
                    renderHome();
                });
            });
        }

        // --- 퀴즈 모드 시작 함수들 ---
        function startCategoryQuiz(cat) {
            const qs = quizDB[cat].filter(q => !q.solved); // 풀지 않은 문제만 추출
            if(qs.length === 0) {
                showAlert('이 분야의 모든 문제를 풀었습니다! 초기화 버튼을 눌러주세요.');
                return;
            }
            startQuizEngine('category', cat, qs);
        }

        function startRandomQuiz() {
            const qs = [];
            Object.values(quizDB).forEach(arr => qs.push(...arr.filter(q => !q.solved)));
            if(qs.length === 0) {
                showAlert('모든 분야의 문제를 완벽하게 풀었습니다! 기록을 초기화하고 다시 도전해보세요.');
                return;
            }
            // 랜덤 모의고사는 최대 20문제로 제한하여 지루함 방지
            const limitedQs = shuffle(qs).slice(0, 20); 
            startQuizEngine('random', null, limitedQs);
        }

        function startBookmarkQuiz() {
            const qs = [];
            Object.values(quizDB).forEach(arr => qs.push(...arr.filter(q => q.bookmarked)));
            if(qs.length === 0) {
                showAlert('북마크한 문제가 없습니다. 퀴즈 화면에서 별 모양 아이콘을 눌러주세요.');
                return;
            }
            startQuizEngine('bookmark', null, qs);
        }

        function startQuizEngine(mode, categoryKey, questionList) {
            state.quizMode = mode;
            state.currentCategory = categoryKey;
            state.questions = shuffle([...questionList]);
            state.currentIndex = 0;
            state.score = 0;
            renderQuestion();
        }

        // --- 문제 렌더링 ---
        function renderQuestion() {
            state.hasAnswered = false;
            const qData = state.questions[state.currentIndex];
            const progress = ((state.currentIndex) / state.questions.length) * 100;

            let headerTitle = "";
            let headerIcon = "";
            let headerColor = "";

            if (state.quizMode === 'category') {
                const info = categoryInfo[state.currentCategory];
                headerTitle = info.name;
                headerIcon = info.icon;
                headerColor = info.color;
            } else if (state.quizMode === 'random') {
                headerTitle = "랜덤 출제 모드";
                headerIcon = "fa-random";
                headerColor = "text-purple-400";
            } else {
                headerTitle = "북마크 모의고사";
                headerIcon = "fa-star";
                headerColor = "text-yellow-400";
            }

            appDiv.innerHTML = `
                <div class="p-6 md:p-8 fade-in flex flex-col h-full min-h-[450px]">
                    <!-- 헤더 영역 -->
                    <div class="flex justify-between items-center mb-6">
                        <button onclick="renderHome()" class="text-slate-400 hover:text-white transition flex items-center gap-2">
                            <i class="fas fa-times"></i> 중단
                        </button>
                        <div class="flex items-center gap-2 px-3 py-1 bg-slate-700 rounded-full border border-slate-600">
                            <i class="fas ${headerIcon} ${headerColor} text-sm"></i>
                            <span class="text-sm font-medium">${headerTitle}</span>
                        </div>
                        <button id="currentBookmarkBtn" onclick="toggleBookmarkCurrent()" class="text-2xl transition ${qData.bookmarked ? 'text-yellow-400' : 'text-slate-500 hover:text-slate-300'}" title="북마크 추가/해제">
                            <i class="fa-${qData.bookmarked ? 'solid' : 'regular'} fa-star"></i>
                        </button>
                    </div>

                    <!-- 프로그레스 바 -->
                    <div class="w-full bg-slate-700 h-2 rounded-full mb-8 overflow-hidden">
                        <div class="bg-blue-500 h-2 rounded-full transition-all duration-500" style="width: ${progress}%"></div>
                    </div>

                    <!-- 문제 영역 -->
                    <div class="flex-grow">
                        <div class="text-sm text-slate-400 mb-2 font-semibold tracking-wider flex justify-between items-center">
                            <span>QUESTION ${state.currentIndex + 1} OF ${state.questions.length}</span>
                            <span class="text-xs px-2.5 py-1 bg-slate-700 rounded text-slate-300 border border-slate-600">${categoryInfo[qData.categoryId].name}</span>
                        </div>
                        <h3 class="text-lg md:text-xl font-bold mb-6 leading-relaxed break-keep">
                            ${qData.q}
                        </h3>

                        <!-- 입력 폼 -->
                        <form id="answerForm" onsubmit="submitAnswer(event); return false;" class="relative">
                            <input type="text" id="answerInput" 
                                class="w-full bg-slate-900 border-2 border-slate-600 text-white px-5 py-4 rounded-xl focus:outline-none focus:border-blue-500 transition text-base" 
                                placeholder="정답 입력 (단답형)" autocomplete="off">
                            <button type="button" onclick="submitAnswer(event)" id="submitBtn"
                                class="absolute right-2 top-2 bottom-2 bg-blue-600 hover:bg-blue-700 text-white px-6 rounded-lg font-bold transition">
                                제출
                            </button>
                        </form>

                        <!-- 피드백 영역 -->
                        <div id="feedbackArea" class="mt-6 hidden rounded-xl p-5 border">
                            <div class="flex items-start gap-4">
                                <div id="feedbackIcon" class="mt-1 text-2xl"></div>
                                <div class="w-full">
                                    <h4 id="feedbackTitle" class="font-bold text-base mb-1"></h4>
                                    <p id="feedbackDesc" class="text-slate-300 leading-relaxed mb-4 text-sm"></p>
                                    
                                    <!-- 풀이 상태 강제 토글 (다음 출제 제어) -->
                                    <div id="solvedToggleContainer" class="hidden">
                                        <label class="inline-flex items-center gap-2.5 text-sm cursor-pointer bg-black/20 px-3 py-2 rounded-lg border border-black/10 hover:bg-black/30 transition w-full sm:w-auto">
                                            <input type="checkbox" id="solvedCheckbox" onchange="toggleSolvedCurrent(this.checked)" class="w-4 h-4 rounded text-blue-500 bg-slate-800 border-slate-600 focus:ring-offset-slate-900 focus:ring-2 focus:ring-blue-500">
                                            <span class="text-slate-200">풀이 완료 체크 (체크 해제 시 다시 출제됩니다)</span>
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 하단 버튼 영역 -->
                    <div class="mt-8 flex justify-between items-center">
                        <div>
                            ${state.currentIndex > 0 ? `<button onclick="prevQuestion()" class="bg-slate-700 hover:bg-slate-600 border border-slate-500 text-white px-5 py-3 rounded-xl font-bold transition flex items-center gap-2 shadow-lg"><i class="fas fa-arrow-left"></i> 이전</button>` : ''}
                        </div>
                        <button id="nextBtn" onclick="nextQuestion()" class="hidden bg-slate-700 hover:bg-slate-600 border border-slate-500 text-white px-8 py-3 rounded-xl font-bold transition flex items-center gap-2 shadow-lg">
                            ${state.currentIndex === state.questions.length - 1 ? '결과 보기' : '다음 문제'} <i class="fas fa-arrow-right"></i>
                        </button>
                    </div>
                </div>
            `;

            setTimeout(() => document.getElementById('answerInput').focus(), 100);
        }

        // 현재 문제 상태 업데이트 함수
        function toggleBookmarkCurrent() {
            const q = state.questions[state.currentIndex];
            q.bookmarked = !q.bookmarked;
            
            const btn = document.getElementById('currentBookmarkBtn');
            btn.className = `text-2xl transition ${q.bookmarked ? 'text-yellow-400' : 'text-slate-500 hover:text-slate-300'}`;
            btn.innerHTML = `<i class="fa-${q.bookmarked ? 'solid' : 'regular'} fa-star"></i>`;
            
            saveData(); // 북마크 상태 로컬 스토리지 저장
        }

        function toggleSolvedCurrent(isChecked) {
            const q = state.questions[state.currentIndex];
            q.solved = isChecked;
            saveData(); // 체크박스 토글 시 로컬 스토리지 저장
        }

        function submitAnswer(e) {
            if (e) e.preventDefault();
            if (state.hasAnswered) return false;

            const inputEl = document.getElementById('answerInput');
            let userAnswer = inputEl.value.trim().toLowerCase().replace(/\s+/g, ''); 

            if (!userAnswer) {
                inputEl.parentElement.classList.add('shake');
                setTimeout(() => inputEl.parentElement.classList.remove('shake'), 400);
                return false;
            }

            state.hasAnswered = true;
            inputEl.disabled = true;
            document.getElementById('submitBtn').disabled = true;
            document.getElementById('submitBtn').classList.add('opacity-50', 'cursor-not-allowed');

            const qData = state.questions[state.currentIndex];
            
            const isCorrect = qData.a.some(validAnswer => {
                const normalizedValid = validAnswer.replace(/\s+/g, '').toLowerCase();
                return userAnswer === normalizedValid;
            });

            // 정답을 맞춘 경우 자동으로 solved(완료) 처리
            if(isCorrect) {
                qData.solved = true;
                saveData(); // 정답 맞췄을 때도 로컬 스토리지 저장
            }

            if (isCorrect) {
                state.score++;
                showFeedback(true, qData.exp, '', qData.solved);
            } else {
                showFeedback(false, qData.exp, qData.a[0], qData.solved);
            }

            document.getElementById('nextBtn').classList.remove('hidden');
            document.getElementById('nextBtn').focus();
            return false;
        }

        function showFeedback(isCorrect, explanation, correctAnswer, isSolved) {
            const area = document.getElementById('feedbackArea');
            const icon = document.getElementById('feedbackIcon');
            const title = document.getElementById('feedbackTitle');
            const desc = document.getElementById('feedbackDesc');
            const inputEl = document.getElementById('answerInput');
            const toggleContainer = document.getElementById('solvedToggleContainer');
            const checkbox = document.getElementById('solvedCheckbox');

            area.classList.remove('hidden');
            area.classList.add('fade-in');

            // 클래스 변경 시 충돌을 막기 위해 명시적으로 기존 상태 제거 후 추가
            inputEl.classList.remove('border-slate-600', 'focus:border-blue-500', 'border-emerald-500', 'border-rose-500');

            if (isCorrect) {
                area.className = 'mt-6 rounded-xl p-5 border fade-in bg-emerald-900/30 border-emerald-500/50';
                inputEl.classList.add('border-emerald-500');
                
                icon.innerHTML = '<i class="fas fa-check-circle text-emerald-400"></i>';
                title.textContent = '정답입니다!';
                title.className = 'font-bold text-base mb-1 text-emerald-400';
                desc.innerHTML = explanation;

                // 정답인 경우에만 풀이 완료 체크박스 표시
                toggleContainer.classList.remove('hidden');
                checkbox.checked = isSolved;
            } else {
                area.className = 'mt-6 rounded-xl p-5 border fade-in bg-rose-900/30 border-rose-500/50';
                inputEl.classList.add('border-rose-500');
                
                icon.innerHTML = '<i class="fas fa-times-circle text-rose-400"></i>';
                title.textContent = '아쉽지만 오답입니다.';
                title.className = 'font-bold text-base mb-1 text-rose-400';
                desc.innerHTML = `<span class="block mb-2 text-rose-200">모범 답안: <strong>${correctAnswer}</strong></span>${explanation}`;

                // 오답인 경우 풀이 완료 체크박스 완전 숨김
                toggleContainer.classList.add('hidden');
            }
        }

        function nextQuestion() {
            if (state.currentIndex < state.questions.length - 1) {
                state.currentIndex++;
                renderQuestion();
            } else {
                renderResult();
            }
        }

        function prevQuestion() {
            if (state.currentIndex > 0) {
                state.currentIndex--;
                renderQuestion();
            }
        }

        function renderResult() {
            const total = state.questions.length;
            const score = state.score;
            const percentage = Math.round((score / total) * 100);

            let headerTitle = "";
            if (state.quizMode === 'category') headerTitle = categoryInfo[state.currentCategory].name;
            else if (state.quizMode === 'random') headerTitle = "랜덤 모의고사";
            else headerTitle = "북마크 모의고사";

            let message = "";
            let emoji = "";
            if (percentage === 100) { message = "완벽합니다! 실전에서도 문제없겠어요."; emoji = "🏆"; }
            else if (percentage >= 75) { message = "훌륭합니다! 조금만 더 다듬으면 완벽해요."; emoji = "🔥"; }
            else if (percentage >= 50) { message = "좋습니다. 복습을 통해 지식을 확실히 내 것으로 만드세요."; emoji = "👍"; }
            else { message = "개념을 다시 한 번 훑어보는 것을 추천합니다. 할 수 있어요!"; emoji = "💪"; }

            appDiv.innerHTML = `
                <div class="p-8 text-center fade-in">
                    <h2 class="text-2xl font-bold mb-2">${headerTitle} 완료!</h2>
                    <p class="text-slate-400 mb-8">${message}</p>

                    <div class="bg-slate-900 rounded-2xl p-8 mb-8 border border-slate-700 shadow-inner">
                        <div class="text-6xl mb-4">${emoji}</div>
                        <div class="text-5xl font-black text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-emerald-400">
                            ${score} / ${total}
                        </div>
                        <div class="text-slate-400 mt-2 font-medium">정답률 ${percentage}%</div>
                    </div>

                    <div class="flex flex-col sm:flex-row gap-4 justify-center">
                        <button onclick="renderHome()" class="px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-xl font-bold transition flex items-center justify-center gap-2 shadow-lg shadow-blue-600/20">
                            <i class="fas fa-home"></i> 홈 화면으로
                        </button>
                    </div>
                </div>
            `;
        }

        // --- 초기화 ---
        window.onload = () => {
            initDB();
            renderHome();

            // ESC 키 입력 시 홈 화면으로 이동 로직 추가
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    const customModal = document.getElementById('customModal');
                    const customAlert = document.getElementById('customAlert');
                    
                    // 모달이나 알림창이 켜져있다면 모달을 닫는 것을 우선
                    if (customModal) {
                        customModal.remove();
                    } else if (customAlert) {
                        customAlert.remove();
                    } else {
                        // 모달이 없다면 홈 화면으로 렌더링
                        renderHome();
                    }
                }
            });
        };
    </script>
</body>
</html>
